---
title: "Datenvisualisierung mit ggplot2"
author: "Sebastian Kuhn"
date: "4 9 2021"
output: html_document
#output: word_document
#output: pdf_document
description: "Skript für die Videocast-Reihe zum Thema Datenvisualisierung mit ggplot2"
tags: ["DataViz", "tutorial", "R", "tidyverse", "ggplot2"]
editor_options:
  chunk_output_type: console
---

```{r set options, include=FALSE}
options(width = 700)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, out.width = "100%",
                      fig.showtext = TRUE, retina = 1)
```

# Datenvisualisierung mit ggplot2 - Videocasts

## Inhalt {#inhalt}

* [Datenvisualisierung mit ggplot2 - Teil 1: Grundlagen](#basics)
  + [Die "Grammar of Graphics"](#grammar)
  + [Ein erster ggplot-Befehl](#Befehl)
  + [Literatur, Blogs und schnelle Hilfe](#Hilfe)
* [Datenvisualisierung mit ggplot2 - Teil 2: Das erste Scatterplot](#scatter)
  + [Und los geht's!](#los)
  + [ggplot-Befehle sinnvoll aufbauen](#Aufbau)

## Datenvisualisierung mit ggplot2 - Teil 1: Grundlagen {#basics}

Herzlich Willkommen zum ersten Teil einer kleinen Video-Tutorial-Reihe zum Thema "Datenvisualisierung mit `ggplot2`". In diesem ersten Teil der Reihe werden wir uns die grundlegende Funktionsweise des Pakets `ggplot` anschauen und dafür erstmal auf einer etwas theoretischeren Ebene stehen bleiben - aber keine  Angst: die Praxisbeispiele kommen noch früh genug in den nächsten Videos! Vorher glaube ich allerdings, dass es erstmal ganz sinnvoll ist, sich einen Überblick über die Grundprinzipien und die Ideen zu verschaffen, die mit `ggplot` verbunden sind - und genau das soll das Thema dieses Videos sein.

Wenn wir damit fertig sind, werde ich Ihnen in den kommenden Videos anhand einiger Beispiele zeigen, wie man Diagramme in `ggplot` Schritt für Schritt aufbaut. Wir starten dabei mit einem Streudiagramm und werden uns später weitere Darstellungsformen und auch komplexere Grafiken anschauen. Am Ende werden Sie - zumindest hoffe ich das - die Grundprinzipien einer effektiven Datenvisualisierung verstehen, und auch wissen, wie man mit `ggplot` eine ziemlich breite Palette an Diagrammen erstellen kann.

Vorab noch ein kurzer Disclaimer: Ich gehe in dieser Einführung davon aus, dass Sie die benötigte Software - also vor allem `R` und `R-Studio` - schon installiert haben und dass Sie auch schon Grundkenntnisse in `R` haben. Zudem ist es mir wichtig, hier zu sagen, dass ich auch mit einer Videoreihe keinen umfassenden Überblick über alle Funktionen von `ggplot` geben kann - vielmehr müssen wir hier zwangsläufig an der Oberfläche bleiben und auch die Beispiele, die ich Ihnen zeigen werde sind keinesfalls als "Kochrezepte" oder als strikte Regelwerke zu verstehen. Wie fast immer bei der Arbeit mit R gibt es auch bei `ggplot` häufig mehr als einen Weg zum Ziel - und gerade bei der Visualisierung von Daten stehen Ihnen zahllose Möglichkeiten zur Verfügung die zum Teil auch mit Geschmack zu tun haben. Das bedeutet allerdings auch, dass `ggplot2` natürlich sehr viel mehr kann als Ihnen im Rahmen dieser Reihe hier zeigen kann. 

Das Ziel dieser Tutorialreihe besteht im Grunde darin, dass Sie einen schnellen Eindruck von der Funktionalität von ggplot bekommen und schnell selbst damit loslegen können, Plots damit zu erstellen. Sie sollten am Ende der Reihe dazu in der Lage sein, einen in `ggplot2` geschriebenen Code im Prinzip zu verstehen, wenn Sie ihn sehen und Sie sollten einen Blick dafür bekommen, wie die "Grammatik" von `ggplot` funktioniert, wie die verschiedenen Ebenen, Formen und Daten zusammengesetzt werden und wie Sie Abbildungen in ggplot selbst Schritt für Schritt aufbauen können.

Noch ein Hinweis an der Stelle: Haben Sie keinen zu großen Respekt vor kompliziert aussehenden Codes - seien Sie sich versichert, dass die wenigsten Menschen, die praktisch täglich mit `ggplot` arbeiten sämtliche Teile des Codes auswendig und fehlerfrei herunterschreiben können. Natürlich wird bei der Erstellung von schicken Grafiken mit `ggplot` andauernd nebenher gegoogelt und auf Cheat-Sheets gespickelt - und das ist auch okay so. Ganz im Gegenteil: Im Netz findet sich eine sehr aktive Community, die zahlreiche Tipps und Tricks zu `ggplot` teilt und auch häufig die Codes und Daten für unglaublich tolle Darstellungen zur Verfügung stellt. Ich werde Ihnen da am Ende des Tutorials noch zwei, drei Hinweise geben. Nutzen Sie diese Möglichkeiten und seien Sie kreativ - das ist letztlich auch Sinn und Zweck der Vernstaltung von `ggplot2`. 

### Die "Grammar of Graphics" {#grammar}

So, jetzt kommen wir aber endlich zum Punkt und schauen uns an, was es mit `ggplot2` auf sich hat. `ggplot` gehört zu der `tidyverse`-Familie, die eine Reihe sehr nützlicher Pakete aus dem Umfeld von `R-Studio`-Entwicklern beinhaltet und das wichtige ist - diese sind und werden auch gut gepflegt. Ursprünglich wurde `ggplot` von Hadley Wickham im Jahr 2005 entwickelt. Wickham hat sich dabei von einem Konzept namens "Grammar of Graphics" inspirieren lassen, das Ende der 1990er Jahre von Leland Wilkinson entwickelt wurde. Das zeigt sich im Übrigen auch an dem Namen des Pakets - die beiden "g" in `ggplot` eben für "grammar" und "grpahics" stehen. 

Ich kann und will an der Stelle nicht zu sehr ins Detail gehen, aber ich glaube es macht durchaus Sinn, sich den Grundgedanken der "Grammar of Graphics" einmal anzuschauen. Die Idee von Wilkinson besteht darin, eine ‘Grammatik’ für Grafiken zu entwickeln - das sagt ja auch schon der Name. Vielleicht fragen Sie sich jetzt, was hat denn "Grammatik" mit Grafik zu tun?. Wenn Sie sich die Sprache vorstellen, dann spielt da die Grammatik eine ganz wichtige Rolle bei der systematischen Beschreibung von Sprache und Grammatik stellt im Prinzip ein Regelwerk zur Verwendung der Sprache zur Verfügung. Beherrscht man dieses Regelwerk, dann ist auf dieser Basis eine unzählige Anzahl an (mehr oder weniger) sinnvollen sprachlichen Aussagen möglich. Analog dazu soll die "Grammar of Graphics" eine Art Sammlung von Konzepten und Regeln darstellen, aus denen wir im Prinzip alle denkbaren und sinnvollen Grafiken und Datenvisualisierungen erstellen können. In seinem - übrigens sehr lesenswerten - Aufsatz zu den Grundlagen von `ggplot` schreibt Wickham selbst, dass diese Grammatik die Grundlage zur Erstellung von graphischen "Gedichten" darstellt. Da wird schon deutlich, dass neben diesem systematischen Aspekt der Grammatik auch ein künstlerischer Aspekt eine Rolle spielt, aber bevor wir uns diesem widmen können müssen wir uns erstmal die Bestandteile der Grammatik genauer anschauen um dazu in der Lage zu sein, systematisch Grafiken mit `ggplot2` erstellen zu können. 

Schauen wir uns nun die Bestandteile der Grammatik einmal näher an. In der Pyramide links sehen sie die wichtigsten Elemente der "Grammar of Graphics" und das Besondere daran ist, dass Sie mit Hilfe dieser Komponenten so ziemlich jede erdenkliche statistische Grafik beschreiben - und mit `ggplot` eben auch erstellen - können.

#### Data
Ganz unten finden Sie da die Daten - und klar, ohne Daten gäbe es nichts, was Sie irgendwie visualisieren könnten. Daten helfen Ihnen Daten aber auch nicht viel - vielmehr müssen Sie irgendwie festlegen, welche Variablen aus Ihren Daten in welcher Form abgebildet werden sollen. Und hiermit ist dann auch das "Aesthetics"-Element der "Grammar of Graphics" angesprochen.  

#### Aesthetics
Mit ästhetischen-Funktionen verlinken Sie letztlich in `ggplot2` Ihre Variable mit bestimmten ästhetischen Darstellungen in der Grafik - beispielsweise legen Sie hier also fest, welche Variablen auf der x- oder y-Achse dargestellt werden sollen oder ob Ihre Variablen mit bestimmten Farben in der Darstellung verbunden werden. Weil es hier um die logische Verbindungen zwischen den Daten und den sichtbaren Elementen in Ihrer Darstellung geht, wird an der Stelle häufig vom sogenannten "aesthetic mapping" gesprochen. 

#### Scale
Sobald dann klar ist, welche Daten für eine Visualisierung verwendet werden sollen, muss auch die Skalierung festgelegt werden. Wenn wir hier von Skalen oder Skalierung sprechen meinen wir beispielsweise die Wertebereiche der x- und y-Achsen. Es macht zum Beispiel keinen Sinn, eine Zeitachse von 1800 bis 2020 darzustellen, wenn Sie nur Daten aus den Jahren 2010 bis 2020 verwenden. Das ist klar. Mit der Skalierung sind aber auch Farb- oder Größenskalen und zahlreiche andere Eigenschaften und Parameter von `ggplot`-Objekten gemeint. Das wird vermutlich klarer, wenn wir uns die Beispiele in den nächsten Videos anschauen. 

#### Geometric Objects
Sobald feststeht, welche Daten in einem Plot dargestellt werden sollen muss wir natürlich auch festlegen, in welcher Form die Daten visualisiert werden - ob Sie zum Beispiel Punktwolke visualisiert haben möchten, Boxplots oder Balkendiagramme - und wenn wir von derlei Visualisierungen sprechen (im `ggplot2`-Kontext), dann ist hier die Rede von "geometrischen Objekten". Für praktisch alle gängigen Formen von Datenvisualisierungen existieren in `ggplot` mittlerweile eigene geometrische Funktionen, zum Beispiel erstellt die Funktion `geom_point()` Streudiagramme, `geom_bar()` erstellt Balkenplots und `geom_boxplot()` erstellt Boxplots.

#### Statistics
Als nächstes Element der "Grammar of Graphics" kommen wir zu statistischen Transformationen oder zu den "Statistics". Was ist darunter zu verstehen? Nicht immer wollen Sie den exakten Wert Ihrer Variablen in einer Abbildung darstellen, vielmehr sind Sie vielleicht an Mittelwerten, Summen oder Auszählungen interessiert oder wollen z.B. den Logarithmus von Werten verwenden. Daher wird in der "Grammar of Graphics" und in `ggplot2` die Möglichkeit einer statistischen Transformation vor der eigentlichen Darstellung offen gelassen. Viele Darstellungen wie z.B. Boxplots oder Histogramme setzen solche statistischen Transformationen ja im Prinzip von vorneherein voraus - bei anderen sind sie dagegen eher optional. Wenn Sie keine statistischen Transformation vornehmen, dann ist im Kontext von `ggplot2` immer mal wieder die Rede von der "transformation identity". Dann werden die Daten nicht verändert, sondern direkt aus dem Datensatz an die jeweilige Ästhetik weitergegeben. 

#### Facets
Das nächste Element in der Pyramide sind die "Facets" - also auf Deutsch so etwas wie Facettenspezifikationen. Konkret ist hier gemeint, dass die ausgewählten Daten vor der eigentlichen Visualisierung noch in verschiedene Teil-Datensätze aufgesplittet werden können. Sie könnten z.B. Ihre Daten nach Ländern oder Jahren separieren und auch in separaten Darstellungen plotten. In diesem Fall verwenden wir dann eine Facettenspezifikation, die zum Beispiel für jedes Land erst einen eigenen Teildatensatz erstellt und erst dann die eigentliche Darstellung. 

#### Coordinate System
Zuletzt ist für die Erstellung einer Grafik immer die Festlegung eines bestimmten Koordinatensystems notwendig, das auch zu den Daten und den geometrischen Objekten passt. Am häufigsten wird hier das sogenannte "kartesische" Koordinatensystem verwendet - für viele Darstellungen - wie zum Beispiel für Streudiagramme - passt das meistens, für andere Darstellungen - wie für Kuchendiagramme - bieten sich aber andere Systeme wie zum Beispiel das polare Koordinatensystem an.

#### Bahnhof
So, vielleicht verstehen Sie jetzt nur noch Bahnhof fragen sich, warum das alles so kompliziert sein muss - und ich gebe zu, dass das alles erstmal ziemlich viel und ziemloich trocken erscheint, ich glaube aber, dass Sie sehr davon profiteren werden, wenn sie zumindest ein Gefühl für die Grundidee von `ggplot` haben, bevor Sie selbst richtig loslegen. 

Und zur Beruhigung: `ggplot` wird Ihnen viel Arbeit abnehmen, da die Entwickler sich hier viele Gedanken über intelligente Voreinstellungen und default-Werte gemacht haben und Sie letztlich einfache Grafiken schon durch die Angabe der Daten, der "Aesthetics"  und der geometrischen Objekte erstellen können ohne dass Sie all die anderen Elemente, die wir gerade angesprochen haben, händisch festlegen oder verändern müssten. Wenn Sie keine weiteren Angaben - also außer der Daten, der "Aesthetics" und der geometrischen Objekte - mehr machen, dann verwendet ggplot grundsätzlich eine Reihe von sehr sorgfältig ausgewählten default-Werte, die in aller Regel zu sehr vernünftigen und vorzeigbaren Ergebnissen führen. Wenn Sie natürlich eine Darstellung für eine Publikation erstellen wollen oder tiefere Einsichten in Ihre Daten haben wollen, dass werden Sie in der Regel noch einiges anpassen müssen - für einen schnellen Einblick in die Daten sind die Voreinstellungen aber - in den meisten Fällen - völlig ausreichend. 

### Ein erster ggplot-Befehl {#Befehl}
So, jetzt wollen wir uns aber mal anschauen, wie diese Grundsätzte der "Grammar of Graphics" in `ggplot` umgesetzt sind. Dafür schauen wir uns jetzt einfach mal einen einfachen Befehl in `ggplot` schematisch an. Hier auf der Folie finden Sie diesen Befehl. 

Was hier passiert ist im Grunde das Folgende: Mit der Funktion `ggplot()` teilen Sie R im Prinzip einfach mit, dass Sie jetzt gerne `ggplot` verwenden würden. Diese Funktion erwartet als Argument in aller Regel immer die Angabe des Datensatzes (und zwar des Datensatzes in dem sich die Variablen befinden, die eben dargestellt werden sollen). Sie übergeben diesen Datensatz im Argument `data =`, wobei diese Angabe im Prinzip optional ist. Die Funktion `ggplot()` erwartet grundsätzlich als erstes einen Datensatz, daher können Sie die Angabe von "data =" im Prinzip auch einfach weglassen. In dem vorliegenden Fall übergeben Sie der Funktion `ggplot()` also einen fiktiven Datensatz namens "df" und legen als nächstes in der Aesthetics-Funktion (also a-e-s) fest, welche Variablen Sie nun konkret verwenden wollen und stellen das sogenannte "Mapping" zwischen den Daten und Ihrer Abbildung her. In diesem Fall wollen Sie also die fiktive Variable x auf der x-Achse darstellen und die fiktive Variable y auf der y-Achse. Damit haben Sie die Daten und die Ästhetik des Plots festgelegt. Nun muss `ggplot` nur noch wissen, welche Darstellungsform verwendet werden soll. Daher fügen Sie nun mit einem `+` eine der zahlreichen `geom_`-Funktionen hinzu - in diesem Fall sollen Punkte geplottet werden - es soll also ein Streudiagramm erstellt werden. 

Manchmal macht es Sinn, sich einen `ggplot`-Befehl einmal ausgesprochen vorzustellen - und das würde in der Variante wie folgt klingen: "Hey ggplot, nimm doch bitte den Datensatz gf, stelle mir die Werte der Variable x auf der x-Achse dar und die Werte der Variable y auf der y-Achse. Und zeichne dann bitte für jede Wertkombination einen Punkt." 

Und das war's dann auch schon - alle anderen Entscheidungen - beispielsweise über die Art des Koordniatensystems oder die Skalierung - würde `ggplot` in diesem Fall selbst treffen (da Sie es nicht getan haben) - und in aller Regel würde das dann auch zu einem vorziegbaren Ergebnis führen. 

### Literatur, Blogs und schnelle Hilfe {#Hilfe}
So, und weil das alles in der Theorie nicht so richtig viel Spaß macht, freue ich mich schon auf die kommenden Videos in denen ich Ihnen zeigen werde, wie `ggplot` in der Praxis funktioniert. Vorher möchte ich Ihnen zum Ende des Videos aber noch ein paar Tipps zur Literatur und Hilfestellungen rund um `ggpplot` an die Hand geben. Ich habe ja schon am Anfang des Videos gesagt, dass Sie keinen allzu großen Respekt vor kompliziert aussehenden Codes haben sollten, sondern sich mit Offenheit und mit Kreativität auf `ggplot` einlassen sollten - und aus meiner Erfahrung heraus ist es hierzu sehr hilfreich, sich einfach mal im Netz anzuschauen, was andere Menschen so alles mit `ggplot` machen und dann auch gegebenenfalls besonders gelungene oder schöne Grafiken einfach einmal selbst zu replizieren. Glücklicherweise gibt es dazu mittlerweile im Netz einen Haufen toller Blogs und ich habe Ihnen hier nur einmal eine ganz kleine Auswahl mitgebracht. 

Sehr ans Herz legen will ich Ihnen beispielsweise die [R-graph-gallery](https://www.r-graph-gallery.com/), die eine Vielzahl an möglichen `ggplots` beinhaltet und auch gleich den Code dazu bereitstellt - und auch beispielsweise den Blog von [Cédric Scherer](https://www.cedricscherer.com/), der wirklich sehr schöne und informative Grafiken erstellt - wie zum Beispiel auch die, die Sie hier auf der Folie sehen können - und der auch zahlreiche Tutorials zu `ggplot2` auf seinen Seiten bereit hält - da lohnt sich ein Blick auf jeden Fall. 

Dann finden Sie hier auf der Folie auch zwei Literaturempfehlungen - die beiden Bücher von Kiran Healy und von Claus Wilke halte ich wirklich für uneingeschränkt empfehlenswert und auch hier ist das schöne, dass beide Autoren ihren Code auf ihren Homepages bzw. auf den github-Seiten auch frei zur Verfügung stellen. Das heißt, Sie können im Grunde alle Abbildungen, die Sie in den Büchern finden auch mit mehr oder weniger großem Aufwand selbst auch nachbauen. 

Zuletzt will ich Sie noch auf die umfangreiche Dokumentation des Pakets auf den [tidyverse](https://ggplot2.tidyverse.org/)-Seiten hinweisen - hier finden Sie in der Regel schnell Informationen zu allen Funktionen von `ggplot2` - und übrigens auch einen sehr hilfreichen Spickzettel mit den wichtigsten Befehlen und Funktionen, den Sie einfach ausdrucken und auf Ihren Schreibtisch legen können. Wenn auch das nicht mehr hilft, dann lege ich Ihnen zum Schluss noch die Plattform [stackoverflow](https://stackoverflow.com/) ans Herz - hier finden Sie insbesondere dann Rat wenn Sie ganz besonders knifflige Fragen oder Probleme haben - da lohnt sich dann ein Blick wenn Sie nicht mehr weiter kommen.

Und nun wünsche ich Ihnen schonmal viel Spaß beim stöbern und freue mich auf die kommenden Videos!

## Datenvisualisierung mit ggplot2 - Teil 2: Das erste Scatterplot {#scatter}

Herzlich Willkommen zum zweiten Teil der Video-Tutorial-Reige zu `ggplot2`. Nachdem ich im ersten Video einiges über die theoretischen Grundlagen von `ggplot2` und über die Grundidee der "Grammar of Graphics" erzählt habe, wird es jetzt Zeit, die Theorie zu verlassen und zur Praxis zu kommen. 

### Die Datenbasis {#data}
Bevor wir aber unser erstes ggplot gemeinsam erstellen, will ich kurz etwas zur Datenbasis sagen, die ich hier verwende. Sie sehen oben hier im Environment, dass bereits ein Datensatz geladen ist - und zwar handelt es sich dabei um einen Auszug aus dem *Quality of Government*-Datensatz des [Quality of Government Institute](https://www.gu.se/en/quality-government) der Universität Göteborg. Der Fokus dieses Datensatzes liegt - wie es der Name erahnen lässt - auf *Good Governance* und beinhaltet Mikro- und Makrodaten aus unterschiedlichen Quellen, die für über 190 Länder aufbereitet werden. Die Daten sind dabei thematisch - beispielsweise nach den Bereichen Bildung, Gesundheit, Migration und Umwelt - gegliedert und der Datensatz liegt in mehreren Varianten vor - so beinhaltet der [Standard-Datensatz](https://www.gu.se/en/quality-government/qog-data/data-downloads/standard-dataset), den wir hier auch nutzen, beispielsweise über 2.000 Variablen wohingegen der [Basic-Datasatz](https://www.gu.se/en/quality-government/qog-data/data-downloads/basic-dataset) eine kompaktere Version mit nur etwa 300 Variablen darstellt. Darüber hinaus liegen viele Daten auch in einem [Zeitreihendatensatz](https://www.gu.se/en/quality-government/qog-data/data-downloads/standard-dataset) vor. Für dieses Tutorial habe ich einen Auszug aus dem Standarddatensatz sowie aus dem Zeitreihendatensatz erstellt, später werden wir auch einen Auszug aus dem Zeitreihendatensatz verwenden, und diese Auszüge enthalten einige Variablen weniger, so dass der Datensatz nicht mehr ganz so groß ist. 

Wie bereits erwähnt, habe ich diesen Auszug aus dem Datensatz in der Session bereits geladen, im Skript finden Sie aber hier unter "Import des QOG Standard-Datensatzes" und "Import des QOG Zeitreihen-Datensatzes" Beispiele zum Laden der vollständigen Datensätze über die Original-URL des Quality of Government Institute. Bevor wird die Datensätze importieren, laden wir via `library(tidyverse)` alle Pakete des `tidyverse`-Universums - darunter neben `ggplot2` auch das Paket `readr`, welches auch die Funktion `read_csv()` beinhaltet, die wir hier verwenden. 

```{r}
## Wichtige Pakete laden und Datensatz importieren
library(tidyverse) # lädt alle Pakete des "tidyverse" - unter anderem ggplot2 und readr

# Import des QOG Standard_Datensatzes

qog <- readr::read_csv("~/Dokumente/R Projekte/ggplot_FUH_Videocast/Data/qog_sample.csv")
#qog <- readr::read_csv("/home/seba/Dokumente/R Projekte/ggplot_tut/Data/qog_std_cs_jan21.csv")
#qog <- readr::read_csv("https://www.qogdata.pol.gu.se/data/qog_std_cs_jan21.csv") #Standard-Datensatz

# Import des QOG Zeitreihen-Datensatz

qog_ts <- readr::read_csv("~/Dokumente/R Projekte/ggplot_FUH_Videocast/Data/qog_ts_sample.csv")
# qog_ts <- readr::read_csv("/home/seba/Dokumente/R Projekte/ggplot_tut/Data/qog_std_ts_jan21.csv")
#qog_ts <- readr::read_csv("https://www.qogdata.pol.gu.se/data/qog_std_ts_jan21.csv") #Zeitreihen-Datensatz
```

### Und los geht's! {#los}

#### Empfehlung
So, und damit geht's los. Bevor wir anfangen möchte ich Ihnen empfehlen, alle Übungen die wir hier machen auch tatsächlich manuell durchzuführen, indem Sie den Code wirklich selbst eintippen (statt ihn zu kopieren und einzufügen). Jetzt werden Sie sich vielleicht fragen: "Code selbst eintippen?" Das klingt in Zeiten des "Copy und Paste" vielleicht ewtas antiquiert, ist aber bei weitem der effektivste Weg, um sich an die Logik von ggplot zu gewöhnen und ein Gefühl für die Syntax von R zu bekommen. Nur wenn Sie selbst Fehler machen - und ich bin mir sicher: das werden Sie unweigerlich tun - werden Sie auch schnell in der Lage sein, die eigenen Fehler zu diagnostizieren und daraus zu lernen.

#### Das erste Streudiagramm
Wenn wir jetzt zum ersten Streudiagramm kommen, dann nehmen wir einfach mal an, wir interessieren uns für den Zusammenhang zwischen der Höhe staatlicher Gesundheitsausgaben und der Lebenserwartung in allen Ländern, für die wir eben Daten haben. Beide Variablen finden sich im Quality of Government-Datensatz - und zwar unter der Bezeichnung `wdi_dgovhexp` - für die öffentlichen Gesundheitsausgaben - und unter der Bezeichnung `wdi_lifexp` - für die Lebenserwartung. Das Präfix "wdi" deutet übrigens auf die ursprüngliche Datenquelle hin - beide Variablen stammen aus den "World Development Indicators"-Datensatz der Welt Bank.

```{r eval=FALSE}
## Variablen:
# wdi_dgovhexp: Öffentliche Ausgaben für Gesundheit aus inländischen Quellen als Anteil der Wirtschaft, gemessen am BIP.
# wdi_lifexp: Die Lebenserwartung bei der Geburt gibt die Anzahl der Jahre an, die ein Neugeborenes leben würde, wenn die zum Zeitpunkt seiner Geburt vorherrschenden Sterblichkeitsmuster zum Zeitpunkt seiner Geburt sein ganzes Leben lang gleich bleiben würden.
```

So, jetzt wollen wir aber wirklich loslegen mit `ggplot` und dazu teilen wir `ggplot` in der Funktion `ggplot()` erstmal mit, in welchem Datensatz sich die Variablen befinden, die uns interessieren. Im ersten Video hatte ich ja bereits gesagt, dass die Funktion `ggplot()` grundsätzlich als erstes Argument Daten erwartet, in diesem Fall also die Daten "qog". Wenn wir diesen Befehl ausführen passiert erstmal... 

```{r}
## Daten übergeben
ggplot(data = qog)
# ggplot(qog) # Führt zum selben Ergebnis
```

...nichts. Naja, das ist nicht ganz richtig - wie Sie gesehen haben hat sich hier im Plot-Fenster das Fenster "eingegraut", d.h. Sie haben eine große graue Fläche erhalten - vielmehr ist aber nicht passiert. Warum?

Naja, im Prinzip kennt `ggplot` ja jetzt nur unsere Daten, weiß aber noch nicht, welche Variablen wir auf welche Weise darstellen wollen. Bevor wir weiter machen nochmal kurz der Hinweis, dass die Angabe von "data=" in diesem Fall optional ist - ich habe ja gesagt: die ´Funktion `ggplot()` geht grundsätzlich davon aus, dass als erstes Argument ein Datensatz übergeben wird und dementsprechend würde auch der Befehl ohne die Angabe "data=" zum selben Ergebnis führen.

Wir müssen ggplot also als nächstes mitteilen, welche Variablen in den Daten durch welche visuelle Elemente im Diagramm dargestellt werden sollen. Diese Zuordnung erfolgt - wie auch im ersten Video schon erläutert - über die "Aesthetics-" bzw. `aes()`-Funktion, die sich in aller Regel sofort an die Angabe des Datensatzes anschließt - und das sieht dann in etwa so aus: 

```{r}
# Das "Mapping-Argument" - die Zuordnung von Variablen zu Aesthetics
ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp))
```

Jetzt haben wir der ggplot()-Funktion also zwei Argumente gegeben: Erstens sagen wir ggplot welchen Datensatz es verwendet werden soll und wo die Variablen zu finden sind, die im Zusammenhang des Plots verwendet werden sollen. Zwar können in einer ggplot-Darstellung durchaus auch zwei oder mehr Datensätze verwendet werden, in aller Regel finden sich aber alle Variablen in einem Datensatz.

Als nächstes folgt das sogenannte "Mapping-Argument", das innerhalb der `aes()`-Funktion angegeben wird. Die Argumente, die wir der Funktion übergeben, sind im Prinzip nichts anderes als Definitionen, die ggplot später verwenden wird. Im vorliegenden Fall könnte man den Codeschnipsel also folgendermaßen übersetzen:
 
"Nimm bitte den Datensatz "qog" zur Hand und stelle die Variable "wdi_dgovhexp" auf der x-Achse und die Variable "wdi_lifexp" auf der y-Achse dar". Wie wir später noch sehen werden, könnten wir Variablen hier auch zu anderen ästhetischen Elementen zuordnen - beispielsweise zu Farben, Formen oder Linientypen - erstmal bleiben wir hier aber bei der Zuordnung zu den Achsen. 

Jetzt führen wir den Befehl einmal aus - und wie Sie sehen ist durch die Ausführung des Befehls etwas mehr passiert als vorhin. Die Ausgabe ist nun nicht mehr vollständig weiß oder grau, sondern R hat bereits die x- und y-Achse erstellt und beschriftet und eine grundlegende Design-Entscheidung bezüglich des Hintergrunds und einiger Hilfslinien getroffen - und das alles ohne dass Sie eine konkrete Aufforderung im ggplot-Code geschrieben hätten. Das liegt daran, dass für diese Ebenen bereits Voreinstellungen definiert wurden, die nun standardmäßig abgerufen werden. 

Das wichtigste aber - nämlich die Darstellung der beiden Variablen - fehlt noch. Das liegt schlicht und ergreifend daran, dass das Mapping alleine noch nichts darüber sagt, wie die Darstellung genau erfolgen soll - ob also Punkte, Balken, Linien oder andere geometrische Objekte gezeichnet werden sollen. Wir müssen dem Plot daher noch mindestens eine weitere Ebene hinzufügen, die über die Art des Diagramms entscheidet. Konkret bedeutet das, dass wir uns für eine der knapp 50 vordefinierten geometrischen Funktion entscheiden müssen, die in `ggplot` enthalten sind. In diesem Fall verwenden wir `geom_point()` - ohne Angabe weiterer Argumente in der Klammer. Durch die bereits vorab definierte Zuordnung der jeweiligen Variablen zu den x- und y-Achsen ist jetzt schon klar, welche x- und y-Werte in einem Streudiagramm darstellt werden sollen. Hinzugefügt wird die `geom_`-Funktion über ein den "+"-Operator.

```{r}
# Das erste Streudiagramm
ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp)) + # Neue Ebenen werden mit dem "+"-Operator hinzugefügt
  geom_point()
```

Jetzt führen wir auch diesen Befehl einmal aus - und siehe da: Schon ist das erste Streudiagramm fertig! Zugegeben, es sieht noch nicht wirklich berauschend aus und würde so vermutlich nicht in einer Studienarbeit oder in einem Journal publiziert werden, aber der erste Schritt ist schonmal getan. Bevor wir uns jetzt aber weiteren Details von `ggplot2` widmen, möchte ich Sie an der Stelle noch auf einige praktische Punkte hinweisen. 

Wenn Sie in Lehbüchern oder im Internet `ggplot2`-Code sehen, dann werden Sie merken, dass es sehr unterschiedliche Vorlieben bezüglich des Code-Stils gibt und dass insbesondere erfahrende R-Nutzer manchmal dazu tendieren, sehr kurzen und effizienten Code zu schreiben, der für Anfänger häufig nicht gut lesbar ist. Ein Beispiel: Mit dem folgenden Code, den ich hier markiere und einmal ausführe, kommen Sie zu dem selben Ergebnis - und das, obwohl er deutlich kürzer ist als der Code weiter oben.

```{r}
# Das erste Streudiagramm - kürzere Variante
ggplot(qog, aes(wdi_dgovhexp, wdi_lifexp)) + geom_point()
```

Wie wir bereits oben bei der optionalen Angabe des "data="-Arguments gesehen haben, sind einige Angaben optional, da die verwendeten Funktionen einige Voreinstellungen haben. Wenn man beispielsweise weiß, dass die Aesthetics-Funktion ohne nähere Angabe immer davon ausgeht, dass als erstes Argument eine x-Variable und als zweites Argument eine y-Variable übergeben wird, dann kann man sich die Angabe von "x=" und "y=" - wie wir sie oben gemacht hatten - auch schlicht und ergreifend sparen. Hier ist allerdings aus meiner Sicht Vorsicht geboten, denn wenn die Reihenfolge der Variablen vertauscht wird, ändert sich natürlich auch die Zuordnung der Variablen zur x- bzw. y-Achse. Das habe ich in dem Befehl hier einmal so gemacht - da ist einfach die Reihenfolge vertausch:

```{r}
# Das erste Streudiagramm - kürzere Variante mit anderer Reihenfolge
ggplot(qog, aes(wdi_lifexp, wdi_dgovhexp)) + geom_point()
```

Und Sie sehen, dann werden die auch die Zuordnungen der Variablen zur x- und zur y-Achse verändert. 

Für Anfänger bietet sich daher die explizite Angabe - auch zur besseren Lesbarkeit - durchaus an. Die explizite Angabe von "x" und "y" "schlägt" dann im Übrigen auch die Reihenfolge der Variablen - also wenn Sie mit "y=" zuerst die y-Variable angeben und dann die x-Variable (mit "x="), dann werden Sie sehen, dass wir wieder das ursprüngliche Diagramm haben und dass die y-Variable - also in dem Fall die Lebenserwartung - auf die y-Achse geplottet wurde, obwohl es die erste Variable in der `aes()`-Funktion ist. Und die Gesundheitsausgaben wurden auf die x-Achse geplottet, obwohl es die zweite Variable war.

```{r}
# Das erste Streudiagramm - y vor x
ggplot(qog, aes(y = wdi_lifexp, x = wdi_dgovhexp)) + geom_point()
```

Kein guter Stil ist die Definition neuer Ebenen in der gleichen Zeile - wie in dem Beispiel mit `+ geom_point()` in der selben Zeile wie der Rest des Codes. Das funktioniert zwar, aber wenn Sie neue `ggplot`-Ebenen auch einfach gleich in neue Zeilen schreiben, dann erhöht das erheblich die Übersicht und Lesbarkeit des Codes. Deswegen würde ich Ihnen empfehlen, sich das gleich von Anfang an anzugewöhnen.

```{r}
# Das erste Streudiagramm - y vor x
ggplot(qog, aes(y = wdi_lifexp, x = wdi_dgovhexp)) + 
  geom_point() # Zur besseren Lesbarkeit und Übersicht bitte in einer neuen Zeile
```

## ggplot-Befehle sinnvoll aufbauen {#Aufbau}
### ggplots als Objekte speichern
Was Sie ebenfalls in nahezu allen Lehrbüchern und Blogbeiträgen zu `ggplot2` häufig sehen werden ist, dass `ggplot`-Nutzer ihre Grafiken meistens gar nicht direkt erstellen sondern schrittweise vorgehen und Zwischenschritte in Objekte speichern - das kommt nämlich auch der Logik der "Grammar of Graphics" im Prinzip entgegen. In unserem Fall sieht das beispielsweise so aus: 

```{r}
# Daten und Mapping in "p" zwischenspeichern
p <- ggplot(qog, aes(y = wdi_lifexp, x = wdi_dgovhexp))
# Darstellung als Scatterplot
p + geom_point()
```

Was hier passiert, ist, dass die Informationen zum Datensatz sowie die Informationen zum Mapping der Variablen auf der x- und y-Achse in einem neuen Objekt namens "p" zwischengespeichert werden und erst im zweiten Schritt wird dann der Darstellungstyp festgelegt oder werden andere Festlegungen getroffen. 

Wenn Sie diese Codeline einmal ausführen, dann passiert im Plotfenster erstmal gar nichts - was passiert, ist dass Sie im Environment ein neues Objekt namens "p" enthalten haben. Eine Darstellung im Plotfenster wird durch die Zuordnung der `ggplot`-Funktion zum Objekt "p" nicht ausgelöst. Wenn Sie eine Darstellung haben möchten, dann würden Sie in dem Fall einfach das Objekt "p" abrufen - und das würde in dem Fall wieder dazu führen, dass Sie (wie wir vorher in dem Beispiel schon gesehen hatten) ein mehr oder weniger leeren Plot ausgegeben bekommen in dem nur die Achsen und die Bezeichnungen angelegt sind, aber noch keine Punkte, denn: Das haben Sie ja hier in der Darstellung noch gar nicht festgelegt. Im zweiten Schritt würden Sie dann z.B. indem Sie zu dem Objekt "p" eine `geom_`-Funktion hinzufügen dann (in diesem Fall ein Scatter-) Plot wirklich darstellen. Durch die Angabe "p + geom_point()" wird Ihnen dann das gewohnte Streudiagramm ausgegeben, das wir ja schon ein paar mal gesehen haben. 

Zwei Punkte sind mir an dieser Stelle wichtig: Erstens die Erkenntnis, dass auch von ggplot erstellte Plots oder Funktionen in R als Objekte gespeichert werden können. Zweitens natürlich - und das ist der wichtige Punkt - die Frage nach dem Sinn der Übung. Meistens dient diese Arbeitsweise dazu, herumexperimentieren zu können, ohne immer wieder Code wiederholen zu müssen. Sie könnten beispielsweise auf diese Art schnell ausprobieren, ob sich nicht vielleicht ein Liniendiagramm besser zur Darstellung der Daten eignen könnte als ein Streudiagramm. In diesem Fall fügen Sie dem Objekt "p" eben nicht die Funktion `geom_point()` hinzu, sondern die Funktion `geom_line()` - die Ihnen ein Liniendiagramm erstellt.  

```{r}
p + geom_line()
```

Das macht offenkundig keinen Sinn. Vielleicht wollen Sie aber mal ein Density-Plot - also ein Dichte-Diagramm - erstellen, das die Verteilung nummerischer Variable in einer bestimmten Weise abbildet - das würden Sie zum Beispiel mit diesem Code hier machen: 

```{r}
p + geom_density_2d() + 
  geom_point()
```

Und auch da kann man sich jetzt darüber streiten, ob das sinnvoll war, es geht mir an der Stelle aber noch gar nicht darum zu verstehen, was hier passiert ist - wichtig ist nur: Durch diesen Aufbau des Codes (und das Zwischenspeichern von Ergebnissen in Objekten) sind Sie in der Lage, schnell und ohne viel weitere Schreibarbeit herumzuexperimentieren - zumindest solange Sie die selbe Datengrundlage und die selben Variablen verwenden. Mein Tipp: Gewöhnen Sie sich das gleich an - ich werde es in den kommenden Videos auch so machen und ich glaube es ist sinnvoll, sich das von Anfang an direkt so anzugewöhnen.

Übrigens müssen Sie das Objekt dabei natürlich nicht zwigend "p" nennen - das "p" hat sich allerdings - vermutlich als Abkürzung für "plot" - weitgehend durchgesetzt und wird Ihnen in vielen Lehrbüchern so begegnen. 

Ich gebe zu, das alles mag für Anfänger etwas kompliziert erscheinen und wir haben jetzt relativ viel Zeit darauf verwendet, ein recht simples Plot zu erstellen - wichtig ist es aber gerade am Anfang das Grundkonzept von ggplot zu verstehen. Und die gute Nachricht ist nun: An diesem Konzept ändert sich auch bei komplexeren Darstellungen nichts grundsätzliches. Komplexere Darstellungen bestehen eben meistens nur aus mehr Ebenen. In den Darstellungen, die wir uns im Laufe der weiteren Videos anschauen werden, werden wir beispielsweise andere `geom()`-Funktionen verwenden, das Koordinatensystem, Skalen, Farben und Beschriftungen ändern - konzeptionell werden wir jedoch immer das Gleiche tun. Deswegen würde ich Ihnen gerne zum Ende des ersten Praxisvideos die zentralen konzeptuellen Schritte bei der Erstellung eines ggplots nochmal wiederholen:

Die zentralen Schritte sind - Erstens - das Sie der `ggplot()`-Funktion mitteilen, welche Daten Sie verwenden wollen, dass Sie dann - Zweitens - `ggplot()` mitteilen, welche Variablen Sie dargestellt haben wollen - und der Einfachheit halber diesen Schritt auch schon in einem Objekt zwischenspeichern. In einem dritten Schritt teilen Sie `ggplot` mit, welchen Darstellungstyp Sie gerne sehen wollen und in einem vierten Schritt können Sie dann weitere Zusatzfunktionen verwenden, um Skalen, Beschriftungen, Markierungen, Titel und vieles mehr hinzufügen. 

```{r eval=FALSE}

# Wir beginnen mit einem möglichst "aufgeräumten" Datensatz und gehen dann wie folgt vor:
# 1. Teilen Sie der Funktion ggplot() mit, welche Daten Sie verwenden wollen.
# 2. Sagen Sie ggplot(), welche Variablen Sie dargestellt haben wollen. Der Einfachheit halber speichern Sie die Ergebnisse der ersten beiden Schritte in ein Objekt namens "p".
# 3. Teilen Sie ggplot mit, welchen Darstellungstyp Sie gerne sehen wollen. Verwenden Sie dazu die vorgesehenen     geom_()-Funktionen, indem Sie diese einzeln und nacheinander zum Objekt "p" hinzufügen.
# 4. Verwenden Sie Zusatzfunktionen, um Skalen, Beschriftungen, Markierungen, Titel und vieles mehr hinzufügen.
```

All' das werden wir uns in den kommenden Videos anschauen - für heute würde ich es gerne dabei bewenden lassen. Bis dahin: viel Spaß beim Ausprobieren und bis zum nächsten Video!


<!-- ## Datenvisualisierung mit ggplot2 - Teil 3: Das erste Scatterplot {#scatter} -->

<!-- Herzlich willkommen zum dritten Teil der Video-Tutorial-Reihe zu `ggplot`. Im letzten Video hatten wir mit dem folgenden Code ein erstes Streudiagramm erstellt: -->

<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp)) -->
<!-- p + geom_point() -->
<!-- ``` -->

<!-- Nun wollen wir uns anschauen, wie wir diese Darstellung mit wenigen Schritten anpassen und verändern können. Ein Blick auf das Streudiagramm legt ja durchaus einen Zusammenhang zwischen den beiden verwendeten Variablen nahe. Häufig ist es allerdings nicht ganz so einfach, Muster aus Streudiagrammen abzulesen - vor allem, wenn die Diagramme viele Punkte enthalten, die sich gegenseitig überlagern. Hier sind häufig Trendlinien, Regressionsgeraden oder Glättungslinien hilfreich. Insbesondere bei der Visualisierung und Interpretation von bivariaten Regressionen sind derlei Visualisierungen sehr nützlich. -->

<!-- In ggplot ist dafür die geometrische Funktion `geom_smooth()` vorgesehen, die dem Plot eine Regressionslinie hinzufügt, die das zugrundeliegende Muster in den Daten am besten beschreibt: -->

<!-- ```{r} -->
<!-- p + geom_smooth() -->
<!-- ``` -->

<!-- Wie Sie der Ausgabe entnehmen können, wurden nun keine Punkte mehr gezeichnet sondern eine sogenannte geglättete Linie. Allerdings hat `ggplot` nicht nur eine Linie, sondern auch gleich einen Vertrauensbereich - also das graue Band um die Linie herum - erstellt, der den Standardfehler für die Linie anzeigt. Ein Blick auf die Meldung in der Konsole gibt darüber hinaus Auskunft darüber, dass für die Berechnung der Linie eine bestimmte Methode verwendet wurde - in diesem Fall wurde als Glättungsverfahren der LOESS-Algorithmus verwendet, der auf einer lokal gewichteten Regressionsfunktion beruht. Da sie `ggplot` in der funktion `geom_smooth()` weder mitgeteilt haben, welche Methode verwendet werden soll, noch dass ein Vertauensbereich dargestellt werden soll, muss es sich bei diesen beiden Punkten offenkundig wieder um vordefinierte Standardeinstellungen handeln. Ich hatte ja bereits in den letzten Videos darauf hingewiesen, dass sich die Entwickler von `ggplot` viele Gedanken über sinnvolle default-Einstellungen gemacht haben, die in vielen Fällen den Bedürfnissen der Nutzern entsprechen. Natürlich können Sie diese defaults aber jederzeit auf Ihre Bedürfnisse anpassen - und zwar indem Sie der `geom_`-Funktion einige Argumente in der Klammer mitgeben. Wollen Sie zum beispiel dass Ihnen `ggplot` eine Linie auf Basis eines simplen linearen Modells ohne Angabe des Vertrauensbereichs erstellt, dann müssten Sie der `geom()`-Funktion in Klammern die Argumente "method = "lm"" (für "linear model") und "se" (für "standard error") = FALSE mitgeben: -->

<!-- ```{r} -->
<!-- p + geom_smooth(method = "lm", se = FALSE) -->
<!-- ``` -->

<!-- Die Linie entspricht nun der Regressionlinie aus einem einfachen linearen Regressionsmodell. Während die Regressionslinie Ihnen dabei helfen kann, Muster aus Ihren Daten zu identifizieren, hat sie natürlich auch einen entscheidenden Nachteil: Sie beschreibt die Punktwolke zwar so genau es im Rahmen der gewählten Methode eben geht, die Ausreißer und Abweichungen von dieser Linie sind aber nun nicht mehr sichtbar. In diesem Sinne kann es überaus sinnvoll sein, die Linie über die jeweilige Punktwolke zu legen. Nichts einfacher als das - um dies zu tun, fügen Sie Ihrem Befehl einfach die Funktion "geom_point()" wieder hinzu: -->

<!-- ```{r} -->
<!-- p + geom_smooth(method = "lm", se = FALSE) + -->
<!--   geom_point() -->
<!-- ``` -->

<!-- Und schon haben Sie beide Informationen in einem Plot. Wenn Sie nun genau hinsehen, sind zwei Interessante Dinge zu beobachten. Erstens können Sie an einigen Stellen erkennen, dass die Linie nicht - wie ich eben angekündigt hatte - ÜBER den Punkten liegt sondern darunter. Das verdeutlicht nochmals die Grundlogik von ggplot2, wonach die Plots aus verschiedenen Ebenen bestehen, die übereinander gelegt werden. Sie können sich die Darstellung wie ein Bild vorstellen: Malen oder zeichnen Sie die Linie vor den Punkten, dann liegen die Punkte zwangsläufig über der Linie. Malen oder zeichnen Sie zuerst die Punkte und dann die Linie, ist es eben andersrum. Tauschen wir also die Reihenfolge einmal durch und verwenden erst "geom_point" und dann "geom_smooth": -->

<!-- ```{r} -->
<!-- p + geom_point() + -->
<!--   geom_smooth(method = "lm", se = FALSE) -->
<!-- ``` -->

<!-- Und schon ist die Linie über den Punkten. Zweitens fällt bei genauerem Hinsehen auf, dass sich die Skalierung verändert hat, nachdem wir wieder die Punkte in das ggplot aufgenommen haben. Schauen wir uns das nochmal an indem wir die Darstellung mit Punkten und Linien neben die Darstellung legen, die nur die Linie enthält. Dafür verwenden wir ein Paket namens "Patchwork", das ich Ihnen in einem späteren Video noch genauer erläutern werde. Für den Augenblick reicht es zu wissen, dass dieses Paket einfach mehrere Plots gleichzeitig über- und nebeneinander darstellen kann. -->

<!-- ```{r} -->
<!-- library(patchwork) -->
<!-- p1 <- p + geom_point() + -->
<!--   geom_smooth(method = "lm", se = FALSE) -->
<!-- p2 <- p + geom_smooth(method = "lm", se = FALSE) -->

<!-- p1 | p2 -->

<!-- ``` -->
<!-- Es ist relativ leicht zu erkennen, dass die beiden Darstellungen nicht die selbe Skalierung aufweisen. Links geht die y-Achse beispielsweise von etwas unter 55 bis 90 während sie rechts von knapp unter 65 bis knapp unter 90 reicht. Auch hier sind die vordefinierten Standardeinstellungen von ggplot am Werke, die dafür sorgen, dass die Skalierung mehr oder weniger optimal an die Daten angepasst wird, die im jeweiligen Diagramm verwendet werden. Da in dem Diagramm auf der rechten Seite nur die Linie dargestellt wird und nicht die Punkte, ist es in einer gewissen Weise nicht notwendig, eine breitere Skalierung zu verwenden. Das ist im Prinzip auch okay so, kann allerdings durchaus verwirren - vor allem wenn man, wie hier, mehrere Plots nebeneinander legt. Deswegen muss die Skalierung natürlich auch anpassbar sein - und natürlich ist sie es auch. -->

<!-- ## Scale -->

<!-- Hier kommt nun die "scale()"-Funktion ins Spiel. Berachten Sie, dass wir diese Funktion bisher noch gar nicht verwendet hatten - ggplot hat also ohne jede Aufforderung automatisch eine passende Skalierung gewählt und eine entsprechende Beschriftung eingefügt. -->
<!-- Um die Skalierung anzupassen hält ggplot zahlreiche scale-Funktionen bereit - einen Überblick erhalten Sie am einfachsten über die ggplot-Referenz im Internet unter [https://ggplot2.tidyverse.org/reference/] oder indem Sie -->

<!-- ```{r} -->
<!-- ??scale_ -->
<!-- ``` -->
<!-- eintippen und sich alle scale-Funktionen des ggplot-Pakets anschauen. Dazu müssen Sie im Hilfe-Fenster zu den entsprechenden ggplot-Funktionen scrollen und können sich dann mit einem Klick weitere Details dazu anschauen. -->

<!-- Es ist zugegbenermaßen anfangs etwas schwierig, die "richtige" scale()-Funktion für den jeweiligen Bedarf zu finden. Im Prinzip steckt die Lösung aber meistens in der Bezeichnung der jeweiligen Funktionen. Beispielsweise gibt es einige scale_color()-Funktionen, die offenkundig etwas mit den Farbskalen zu tun haben, die in der Abbildung verwendet werden. Dazu kommen wir später noch. Andere Funktionen beziehen sich auf die Größe oder die Form von Objekten (scale_size_... und scale_shape...). Wir wollen in dem Fall aber die x- und y-Achsen anpassen. Hierfür stehen eine Reihe von scale_x_- bzw. scale_y_-Funktionen zur Verfügung. Weil beide Variablen aus unserem Beispiel kontinuerliche Variablen sind, verwenden wir zur Anpassung also die scale_x_continous()-Funktion. Im Falle von kategorialen Variablen würden wir die scale_x_discrete()-Funktion verwenden. Zudem stehen noch weitere Funktionen - zum Beispiel für Datumsformate - zur Verfügung. -->

<!-- Passen wir nun also die Saklierung der x-und y-Achse an. Dafür benötigen wir die Funktionen scale_x_continous() und scale_y_continous(). Mit dem Argument "limits" lassen sich nun die Endpunkte der Skalierung anpassen. Wenn wir beispielsweise wollen, dass beide Achsen einen Wertebereich zwischen 0 und 100 abdecken, dann würden wir folgendermaßen vorgehen: -->

<!-- ```{r} -->
<!-- p + scale_x_continuous(limits = c(0, 100)) + -->
<!--   scale_y_continuous(limits = c(0, 100)) -->
<!-- ``` -->

<!-- Für unser vorliegendes Beispiel ist eine so breite Skalierung nicht nötig, hier reicht uns ein Wertebereich von 0 bis 13 auf der x-Achse und von 50 bis 90 auf der y-Achse. Wie wir nun erkennen weißen beide Plots - das Punktdiagramm und die Darstellung der Regressionslinie - die selbe Skalierung auf: -->

<!-- ```{r} -->

<!-- p + geom_point() + -->
<!--   scale_x_continuous(limits = c(0, 13)) + -->
<!--   scale_y_continuous(limits = c(50, 90)) -->

<!-- p + geom_smooth(method = "lm", se = FALSE) + -->
<!--   scale_x_continuous(limits = c(0, 13)) + -->
<!--   scale_y_continuous(limits = c(50, 90)) -->

<!-- ``` -->
<!-- Noch deutlicher wird es, wenn wir die beiden Darstellungen wieder nebeneinander legen: -->

<!-- ```{r} -->
<!-- p1 <- p + geom_point() + -->
<!--   geom_smooth(method = "lm", se = FALSE) + -->
<!--   scale_x_continuous(limits = c(0, 13)) + -->
<!--   scale_y_continuous(limits = c(50, 90)) -->

<!-- p2 <- p + geom_smooth(method = "lm", se = FALSE) + -->
<!--   scale_x_continuous(limits = c(0, 13)) + -->
<!--   scale_y_continuous(limits = c(50, 90)) -->

<!-- p1 | p2 -->
<!-- ``` -->
<!-- Nun können Sie natürlich nicht nur die Endpiunkte der Skalierung manuell festlegen sondern auch den Intervall, der abgebildet werden soll. Hierfür verwenden Sie das Argument "breaks" innerhalb der scale_continuous-Funktion. Wenn Sie z.B. auf der y-Achse statt des autmatisch ausgewählten 10er-Intervalls lieber ein 5-er Intervall angezeigt haben würden, dann könnten Sie dies folgendermaßen tun: -->


<!-- ```{r} -->
<!-- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp)) + -->
<!--   scale_x_continuous(limits = c(0, 13)) +  -->
<!--   scale_y_continuous(limits = c(50, 90), breaks = c(50, 55, 60, 65, 70, 75, 80, 85, 90))  -->
<!-- ``` -->
<!-- Das sieht etwas mühsam und unnötig kompliziert aus - und das ist es auch. Einfacher ist es, wenn Sie sich hier der seq()- Funktion von R bedienen, die automatisch eine Sequenz von Daten nach einem vorgebenen Muster generiert. Wenn Sie beispielswesie die oben dargestellte Zahlenreihe automatisch generieren wollen, dann übergeben Sie der Funktion seq() einfach den Anfangs- und Endpunkt der Zahlenreihe sowie das gewünschte Intervall. In diesem Fall also den Anfangswert 50, den Endwert 90 und das Intervall von 5: -->

<!-- ```{r} -->
<!-- seq(from = 50, to = 90, by = 5) -->
<!-- # Zum selben Ergebnis kommen Sie mit dieser deutlich kürzeren - aber auch etwas "leserunfreundlicheren" Variante: -->
<!-- seq(50,90,5) -->
<!-- ``` -->

<!-- Legen wir also nun für unser Beispiel ein 5-er Intervall für die y-Achse und ein 2er-Intervall für die x-Achse fest: -->

<!-- ```{r} -->
<!-- p + geom_point() + -->
<!--   scale_x_continuous(limits = c(0, 13),  -->
<!--                      breaks = seq(0, 13, 2)) +  -->
<!--   scale_y_continuous(limits = c(50, 90),  -->
<!--                      breaks = seq(50, 90, 5))  -->

<!-- ``` -->
<!-- Nun zu einem kleinen Trick: Wenn Sie wissen möchten, welche Argumente Sie in einer Funktion noch so verwenden können, dann können Sie einfach innerhalb der Funktion - am besten direkt am Anfang oder nach einem Komma - die "Tab"-Taste drücken und erhalten dann ein Dropdown-Menü, in dem Ihnen die zur Verfügung stehenden Argumente angezeigt werden. Natürlich empfiehlt sich fürs Detail hier auch ein Blick in die Referenz bzw. die Dokumentation des Pakets, insbesondere wenn Sie sich nicht mehr ganz sicher sind, wie ein Argument genau bezeichnet ist, ist dieser Weg aber häufig der schnellste. Wenn Sie dann noch mit der Maus über eines der Argumente fahren, dann werden weitere Erläuterungen dazu eingeblendet. Wie Sie sehen können, gibt es noch eine Vielzahl weiterer Argumente in dieser Liste, mit deren Hilfe Sie Ihre Abbildung anpassen können. Wir können an dieser Stelle nicht auf alle eingehen, schauen uns aber noch das Argument "name" an - mit diesem können Sie die Bezeichnung der Achse steuern. Der angezeigte Hilfetext teilt Ihnen mit, dass per default einfach der Name der jeweiligen Variable angezeigt wird - das war ja bei den bisherigen Plots auch der Fall. Sie können aber natürlich auch andere Namen vergeben oder mit der Angabe von "NULL" die Ausgabe eines Labels unterdrücken.  -->


<!-- ```{r} -->
<!-- p + geom_point() + -->
<!--   scale_x_continuous(limits = c(0, 13),  -->
<!--                      breaks = seq(0, 13, 2), -->
<!--                      name = "Gesundheitsausgaben") +  -->
<!--   scale_y_continuous(limits = c(50, 90),  -->
<!--                      breaks = seq(50, 90, 5), -->
<!--                      name = "Lebenserwartung")  -->

<!-- ``` -->
<!-- Übrigens - und dauch das ist typisch für R - ist das nicht die einzige Möglichkeit um die Beschriftung der Achsen zu verändern. Dafür können Sie auch die ggplot-Funktion "labs()" verwenden, die speziell für die Beschriftung von ggplot-Grafiken erstellt wurde. Hiermit können Sie nicht nur die Achsen beschriften sondern auch einen Titel ("title") bzw. Untertitel ("subtitle") oder eine Bildunterschrift ("caption") erstellen, oder alle möglichen Elemente eines ggplots bennenen - beispielsweise Legenden.  -->


<!-- ```{r} -->

<!-- p + geom_point() + -->
<!--   scale_x_continuous(limits = c(0, 13),  -->
<!--                      breaks = seq(0, 13, 2)) +  -->
<!--   scale_y_continuous(limits = c(50, 90),  -->
<!--                      breaks = seq(50, 90, 5)) + -->
<!--   labs(x = "Gesundheitsausgaben",  -->
<!--        y = "Lebenserwartung",  -->
<!--        title = "Überschrift",  -->
<!--        subtitle = "Unterüberschrift",  -->
<!--        caption = "Quelle: QOG") -->

<!-- ``` -->

<!-- Doch kommen wir nochmal für ein etwas spezielleres Beispiel zurück auf die verschiedenen scale()-Funktionen. Bisher haben wir nur lineare Skalen verwendet, in einigen Fällen kann es durchaus sinnvoll sein eine lineare Skala in eine logarithmische Skala umzuwandeln. Auch das geht mit ggplot2 ziemlich fix und zwar mit einer Funktion namens scale_x_log10(). Diese skaliert die x-Achse eines Diagramms auf der Basis von log 10. Um sie zu verwenden, fügen wir sie einfach zum Diagramm hinzu.  -->

<!-- An dieser Stelle ein kleiner Praxistipp: Zum herumexperimentieren bietet es sich an, einzelne Codeschnipsel nicht gleich zu löschen oder zu überschreiben, sondern "auzukommentieren". Indem Sie eine Raute vor bestimmte Code-Elemente setzen bringen Sie R dazu, diese Elemente als Kommentar zu behandeln und eben nicht auszuführen. So können Sie schnell und einfach verschiedene Darstellungsvarianten ausprobieren ohne jedesmal viel Schreibarbeit zu haben. Wenn Sie mehrere Zeilen gleichzeitig auskommentieren wollen müssen Sie übrigens nicht händisch vor jede Zeile eine Raute schreiben, vielmehr können Sie dafür die betreffenden Zeilen mit der Maus oder der Tastatur markieren und dann mit dem Tastenkürzel Umschalt+Steuerung+c die Zeilen Auskommentieren (und wieder zurückbringen). -->


<!-- ```{r} -->

<!-- p + geom_point() + -->
<!--   # scale_x_continuous(limits = c(0, 13),  -->
<!--   #                    breaks = seq(0, 13, 2)) +  -->
<!--   scale_x_log10() + -->
<!--   scale_y_continuous(limits = c(50, 90), -->
<!--                      breaks = seq(50, 90, 5)) + -->
<!--   labs(x = "Gesundheitsausgaben",  -->
<!--        y = "Lebenserwartung",  -->
<!--        title = "Überschrift",  -->
<!--        subtitle = "Unterüberschrift",  -->
<!--        caption = "Quelle: QOG") -->


<!-- ``` -->

<!-- Wir werden uns später noch intensiver mit weiteren Skalentransformationen beschäftigen, für den Moment belassen wir es aber dabei. Im nächsten Schritt wollen wir uns nämlich erst einmal anschauen, wie wir noch weitere Variablen in die Darstellung einbeziehen können. -->

<!-- Bisher haben wir uns den Zusammenhang zwischen den Gesundheitsausgaben einiger Länder und der Lebenswerwartung in den Ländern angeschaut. Jetzt könnte es interessant sein, etwas mehr über die einzelnen Punkte zu erfahren - beispielsweise welche Länder sich konkret dahinter verberger oder ob sich auf der Basis des Streudiagramms Erkenntnisse bezüglich bestimmter regionaler Häufungen ziehen lassen. Starten wir damit, Informationen über die Länder zu erhalten.  -->

<!-- Eine Möglichkeit dafür bestünde darin, die Punkte in Abhängigkeit des Ländernamens oder eine Länder-ID unterschiedlich einzufärben. Im Quality of Government-Datensatz existieren dafür mehrere Variablen - zum Beispiel die Variable  -->


<!-- ```{r} -->
<!-- qog %>% -->
<!--   select(ccodealp, ccode, cname) %>%  -->
<!--   head() -->

<!-- ``` -->

<!-- Nehmen wir also den ursprünglichen Code wieder zur Hand und versuchen die Punkte in Abhängigkeit des Länderkürzels "ccodealp" einzufärben. Dazu fügen wir der Funktion aes das Argument "colour" hinzu und übergeben hier die entsprechende Variable. Hier geschieht wieder ein "Mapping" - also eine Zuordnung der Werte einer Variable zu einer bestimmten Darstellungsform - in dem Fall zur Farbe: -->

<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, colour = ccodealp)) -->
<!-- p + geom_point()  -->

<!-- ``` -->

<!-- Hups - was ist hier passiert? Nun, ggplot hat in der Tat die Punkte unterschiedlich eingefärbt und automatisch eine Legende hinzugefügt. Sonderlich hilfreich ist das in diesem Fall allerdings nicht, denn der Datensatz beinhaltet einfach zu viele Länder. So wird erstens die Legende viel zu groß, zweitens lassen sich die Punkte nicht gut voneiander unterscheiden, da die Farben zu ähnlich sind. Wären nur 5 oder zehn Länder in dem Datensatz würde das ganz prima funktionieren - im vorliegenden Fall leider nicht. Was Sie aber wieder sehen können, ist dass R per default bereits eine Farbskala gewählt hat und eine Legende hinzugefügt hat. Wie wir später noch sehen werden lassen sich natürlich auch Farbe und Legende noch anpassen - jetzt versuchen wir aber erstmal die Ländernamen auf eine andere Weise abzubilden. Dazu verwenden wir diesmal das Arguemnt "label" innerhalb der Funktion aes(). Wenn wir dann das Streudiagramm neu erstellen, passiert erstmal... -->

<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, label = ccodealp)) -->
<!-- p + geom_point()  -->


<!-- ``` -->
<!-- ...nichts, da das Arguemnt "label" alleine für die Punktdarstellung keine Konsequenzen hat. Fügen wir aber nun das geom "label" hinzu, werden die Punkte "gelabelt" - oder eben benannt: -->

<!-- ```{r} -->
<!-- p + geom_point() +  -->
<!--   geom_label() -->
<!-- ``` -->
<!-- Hier wurden nun "Labels" erstellt die ein wenig an bedruckte Etiketten erinnern. Aufgrund der großen Anzahl an Ländern ist auch dies nun wenig hilfreich, wenngleich zumindest einzelne Länder nun einfacher zu erkennen sind. Eine mögliche Alternative bestünde nun darin, das geom "text" zu verwenden, wodurch nur der Text dargestellt wird - ohne eine Umrandung und Einfärbung:  -->

<!-- ```{r} -->
<!-- p +  -->
<!--   #geom_point() +  -->
<!--   geom_text() -->
<!-- ``` -->
<!-- Auch noch nicht so viel besser. Letzter Versuch: Die Verwendung des Pakets ggrepel - einer Erweitwerung von ggplot, das Labels erstellt, die sich gegenseitig nicht überlappen sollen: -->

<!-- ```{r} -->
<!-- library(ggrepel) -->

<!-- # p + geom_point() +  -->
<!--   #geom_text_repel(max.overlaps = 100) -->
<!--   # geom_label_repel() -->
<!-- ``` -->
<!-- Okay, auch das funktioniert nicht. Es sind einfach zu viele Datenpunkte auf der Abbildung. Dennoch haben Sie nun mehrere nützliche Möglichkeiten gesehen, die sie verwenden könnten, wenn Sie etwas weniger Daten in ihrem Datensatz haben. Für den vorliegenden Fall ist es vermutlich sinnvoller, nicht nach einzelnen Ländern sondern nach anderen Merkmalen zu unterscheiden. Gibt es Variablen in unseren Daten, die sinnvollerweise auf die Farbästhetik abgebildet werden können? Wir könnten beispielsweise versuchen, die Datenpunkte nach dem Kontinent einzufärben, auf dem sich die jeweiligen Länder befinden: -->

<!-- ```{r} -->
<!-- # p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, colour = continent)) -->
<!-- # p + geom_point()  -->
<!-- ``` -->

<!-- Hier wurden nun die einzelnen Datenpunkte nach Kontinenten eingefärbt, und eine Legende mit einem Schlüssel zu den Farben wurde automatisch hinzugefügt. Das sieht schon sehr viel besser und handlicher aus. Und: Jetzt können Sie sich wieder auf die Suche nach einem Muster machen - beispielsweise clustern die afrikanischen Länder (rot) erkennbar links unten und die europäischen Länder rechts oben.  -->

<!-- Eine weitere Möglichkeit bestünde darin, di             labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))e Größe der Länder noch  -->


<!-- ```{r} -->
<!-- # p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = wdi_pop, color = continent)) -->
<!-- # p + geom_point() + -->
<!-- #   scale_size(name   = "Einwohnerzahl", -->
<!-- #              breaks = c(1000000, 10000000, 100000000, 1000000000), -->
<!-- #              labels = expression("< 1 Mio.", "1-10 Mio.", "10-100 Mio.", "> 100000 Mio.")) -->
<!-- ``` -->

<!-- ## Mapping vs. Setting -->

<!-- Kommen wir nun zu einer wichtigen Unterscheidung - und zwar der Unterscheidung zwischen einem ästhetischen "Mapping" und einer fixen Einstellung. Wie wir gesehen haben, können wir beispielsweise mit einem Mapping innherhalb der aes()-Funktion eine Variable durch ein bestimmtest visuelles Element wie Größe, Farbe oder Form darstellen. Schauen wir uns diesen Code nochmals an: -->

<!-- ```{r} -->
<!-- # p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = wdi_pop, color = continent)) -->
<!-- # p + geom_point()  -->
<!-- ``` -->
<!-- Dieser Code gibt keine direkte Anweisung wie "stelle die Punkte sehr gro dar" oder "färbe alle Punkte in rot". Stattdessen heißt es: "Die Eigenschaft 'Farbe' soll durch die Variable "Kontinent" repräsentiert werden und die Größe der Punkte soll in Abhängigkeit der Eiwohnerzahl variieren. Wenn wir alle Punkte in der Abbildung in blau einfärben wollten und alle Punkte gleichermaßen vergrößern wöllten, dass müssten wir diese Festlegung außerhalb der Mappinng-Funktion also außerhalb von aes() tun. Schauen wir uns das mal an. Wir versuchen innerhalb der aes()-Funktion die Größe der Punkte auf den Wert 4 zu setzen und alle Punkte in blau einzufärben: -->

<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = 4, color = "blue")) -->
<!-- p + geom_point()  -->
<!-- ``` -->
<!-- Tatsächlich passiert hier auch etwas - allerdings nicht unbedingt das, was wir wollten. Es werden plötzlich zwei neue Legenden erstellt und die Punkte sind alle rot und nicht blau. Warum? -->

<!-- Nun, ggplot hat versucht gebau das zu tun, was es soll. Innerhalb der aes()-Funktion erwartet ggplot eine Zuordnung von Variablen zu bestimmten visuellen Eigenschaften. Wenn sie hier nun das Argument colour verwenden, geht ggplot davon aus, dass Sie hier auch eine Variable übergeben. Wir haben aber stattdessen nur ein Wort angegeben, nämlich "blau". Dennoch wird aes() sein Bestes tun, um dieses Wort so zu behandeln, als wäre es eine Variable. Aufgrund bestimmter Recycling-Regeln von R wird nun in der Tat eine Variable für Ihre Daten erstellt, die für alle Fälle in Ihrem Datensatz die Zeichenkette "blue" beinhaltet. Dann stellt ggplot die Ergebnisse im Diagramm dar, wie Sie es gewünscht haben indem es sie auf die Farbästhetik abbildet.  -->

<!-- Denken Sie also immer daran, dass die aes()-Funktion nur für Mappings gedacht ist. Verwenden Sie sie nicht, um Eigenschaften auf einen bestimmten Wert zu ändern. Wenn wir eine Eigenschaft setzen wollen, tun wir das in dem von uns verwendeten geom_ und außerhalb der Zuordnung in der aes(...)-Funktion. Versuchen Sie also folgendes: -->

<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp)) -->
<!-- p + geom_point(size = 4, color = "blue")  -->
<!-- ``` -->

<!-- Sie sehen: Die Funktion geom_point() kann ein Farbargument direkt annehmen, und R weiß auch, welche Farbe "blue" ist. Nun können Sie also herumexperimentieren und die Grundeigenschaften Ihrer "Punkte" verändern: -->

<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp)) -->
<!-- p + geom_point(size = 4, color = "blue", alpha = 0.5)  -->
<!-- ``` -->

<!-- Verwenden Sie zum Beispiel das Argument alpha um die Transparenz Ihrer Objekte zu steuern. Dabei können sie Werte zwischen 0 und 1 setzen. Ein Objekt mit einem Alpha-Wert von Null ist vollständig transparent. Ein Objekt mit einem Alpha von eins ist vollständig undurchsichtig. Die Verwendung von Transparenten Objekten iust dabei übrigens nicht nur eine graphische Spielerei, vielmehr können transparente Objekte sehr nützlich sein, wenn viele sich Punkte oder Objekte überlappen - wenn es also zum sog. Overplotting kommt. Sie können durch eine sehr hohe TRansparenz so zum Beispiel Ballungen in den den Daten leichter erkennen - wie z.B. so: -->

<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp)) -->
<!-- p + geom_point(color = "black", alpha = 0.1)  -->
<!-- ``` -->




<!-- ```{r} -->
<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = wdi_pop, fill = continent)) -->
<!-- p + geom_point(shape = 21, alpha = 0.7) + -->
<!--   scale_x_continuous(limits = c(0, 12),  -->
<!--                      breaks = seq(0, 13, 2)) +  -->
<!--   scale_y_continuous(limits = c(50, 85),  -->
<!--                      breaks = seq(50, 90, 5)) + -->
<!--   scale_size(name   = "Einwohnerzahl", -->
<!--              breaks = c(1000000, 10000000, 100000000, 1000000000), -->
<!--              labels = expression("< 1 Mio.", "1-10 Mio.", "10-100 Mio.", "> 100000 Mio.")) +  -->
<!--   labs(x = "Gesundheitsausgaben in Prozent",  -->
<!--        y = "Lebenserwartung",  -->
<!--        size = "Einwohnerzahl", -->
<!--        fill = "Kontinent",  -->
<!--        title = "Überschrift",  -->
<!--        subtitle = "Unterüberschrift",  -->
<!--        caption = "Quelle: QOG") + -->
<!--   theme_minimal() -->




<!-- ``` -->

<!-- p <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = wdi_pop, colour = continent,   fill = continent)) -->
<!-- p + geom_point(alpha = 0.7) + -->
<!--   scale_x_continuous(limits = c(0, 12),  -->
<!--                      breaks = seq(0, 13, 2)) +  -->
<!--   scale_y_continuous(limits = c(50, 85),  -->
<!--                      breaks = seq(50, 90, 5)) + -->
<!--   scale_size(name   = "Einwohnerzahl", -->
<!--              breaks = c(1000000, 10000000, 100000000, 1000000000), -->
<!--              labels = expression("< 1 Mio.", "1-10 Mio.", "10-100 Mio.", "> 100000 Mio.")) +  -->
<!--   labs(x = "Gesundheitsausgaben",  -->
<!--        y = "Lebenserwartung",  -->
<!--        size = "Einwohnerzahl", -->
<!--        fill = "Kontinent",  -->
<!--        title = "Überschrift",  -->
<!--        subtitle = "Unterüberschrift",  -->
<!--        caption = "Quelle: QOG") -->



<!-- ^```{r} -->
<!-- p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y=lifeExp)) -->
<!-- p + geom_point(alpha = 0.3) + -->
<!-- geom_smooth(method = "gam") + -->
<!-- scale_x_log10(labels = scales::dollar) + -->
<!-- labs(x = "GDP Per Capita", y = "Life Expectancy in Years", -->
<!-- title = "Economic Growth and Life Expectancy", -->
<!-- subtitle = "Data points are country-years", -->
<!-- caption = "Source: Gapminder.") -->
<!-- ``` -->

<!-- Jetzt können wir ein einigermaßen ausgefeiltes Diagramm erstellen. Wir setzen die Alpha der Punkte auf einen niedrigen Wert, machen schönere x- und y-Achsenbeschriftungen, und fügen einen Titel, einen Untertitel und eine Beschriftung hinzu. Wie Sie im Code sehen können zu sehen ist, werden zusätzlich zu x , y und anderen ästhetischen Zuordnungen in (z. B. Größe, Füllung oder Farbe) kann die Funktion labs() auch den Text für Titel, Untertitel und Beschriftung festlegen. Sie steuert die Hauptbeschriftungen der Skalen. Das Aussehen von Dingen wie Achsentick- ist Aufgabe verschiedener scale_-Funktionen, wie z. B. der Funktion scale_x_log10() Funktion, die hier verwendet wird. Wir werden mehr darüber erfahren was mit scale_ Funktionen gemacht werden kann. Gibt es Variablen in unseren Daten, die sinnvollerweise auf die Farbästhetik abgebildet werden können? auf die Farbästhetik abgebildet werden können? Nehmen wir den Kontinent. In Abbildung 3.14 sind die wurden die einzelnen Datenpunkte nach Kontinenten eingefärbt, und eine Legende mit einem Schlüssel zu den Farben wurde automatisch in die der Darstellung hinzugefügt. Außerdem haben wir jetzt statt einer Glättungslinie fünf. Es gibt eine für jeden einzelnen Wert der Kontinentvariable. Dies ist eine Folge der Art und Weise, wie ästhetische Zuordnungen inhärent sind. tung. Zusammen mit x und y wird die ästhetische Farbzuordnung in Aufruf von ggplot() festgelegt, mit dem wir das p-Objekt erstellt haben. Wenn nicht anders angegeben -->
<!-- werden alle Geoms, die auf das ursprüngliche Plot-Objekt gelegt werden die Mappings dieses Objekts übernehmen. In diesem Fall erhalten wir sowohl unsere Punkte und Glättungen nach Kontinenten gefärbt. -->

<!-- ```{r} -->
<!-- p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, -->
<!-- color = continent)) -->
<!-- p + geom_point() + geom_smooth(method = "loess") + scale_x_log10() -->
<!-- ``` -->
<!-- Wenn es das ist, was wir wollen, dann könnten wir auch in Betracht ziehen, das Standardfehlerband jeder Zeile schattieren, damit es der dominierenden Farbe entspricht, wie in Abbildung 3.15. Die Farbe des Standardfehlerbandes wird durch die durch die Füllungsästhetik gesteuert. Während die Farbästhetik das Während die Farbästhetik das Aussehen von Linien und Punkten beeinflusst, ist die Füllung für die gefüllten Bereiche von Balken, Polygone und, in diesem Fall, das Innere des Standardfehlerbandes des Glätters. Fehlerbandes. -->

<!-- ```{r} -->
<!-- p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, -->
<!-- color = continent, fill = continent)) -->
<!-- p + geom_point() + geom_smooth(method = "loess") + scale_x_log10() -->
<!-- ``` -->
<!-- Wenn Sie sicherstellen, dass Farbe und Füllungsästhetik konsistent übereinstimmen auf diese Weise wird das Gesamtbild des Plots verbessert. Um dies zu erreichen müssen wir nur festlegen, dass die Zuordnungen jeweils auf dieselbe Variable sind. -->



<!-- Vielleicht sind fünf verschiedene Glätter zu viel, und wir wollen nur eine Linie. Trotzdem möchten wir die Punkte farblich nach Kontinenten kodiert nach Kontinent. Standardmäßig erben Geoms ihre Mappings von der ggplot() Funktion. Wir können dies ändern, indem wir verschiedene Ästhetik für jedes Geom angeben. Wir verwenden denselben Ausdruck mapping = aes(...) Ausdruck wie beim ersten Aufruf von ggplot(), verwenden ihn aber jetzt auch in den geom_-Funktionen und geben die Mappings an, die wir auf die einzelnen Funktionen anwenden wollen die wir auf jede Funktion anwenden wollen (Abb. 3.16). Die in der ursprünglichen ggplot()-Funktion angegebenen Mappings Funktion angegebenen Zuordnungen - hier x und y - werden für alle nachfolgenden geoms. -->

<!-- ```{r} -->
<!-- p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) -->
<!-- p + geom_point(mapping = aes(color = continent)) + -->
<!-- geom_smooth(method = "loess") + -->
<!-- scale_x_log10() -->
<!-- ``` -->

<!-- Es ist möglich, kontinuierliche Variablen der Farbästhetik zuzuordnen, abzubilden. Zum Beispiel können wir den Logarithmus der Bevölkerung eines jeden Länderjahres ( pop ) auf die Farbe abbilden. (Wir können den Logarithmus der Bevölkerung direkt in der aes()-Anweisung der aes()-Anweisung unter Verwendung der log()-Funktion. R wertet dies für uns aus.) Wenn wir dies tun, erzeugt ggplot eine Gradientenskala. Sie ist kontinuierlich, wird aber in der Legende in Intervallen markiert. Je nach Umständen können Größen wie die Bevölkerung auf einen kontinuierlichen Farbverlauf abgebildet werden. kontinuierlichen Farbverlauf (Abb. 3.17) mehr oder weniger effektiv sein als als die Einteilung der Variable in kategorische Bereiche, z. B. von niedrig bis hoch. Im Allgemeinen lohnt es sich immer, die Daten zunächst in ihrer kontinuierlichen Form zu betrachten. Es lohnt sich immer, die Daten zunächst in ihrer kontinuierlichen Form zu betrachten, anstatt sie in Kategorien zu zerschneiden oder einzuteilen. -->


<!-- ```{r} -->
<!-- p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) -->
<!-- p + geom_point(mapping = aes(color = log(pop))) + scale_x_log10() -->
<!-- ``` -->

<!-- Es lohnt sich, der Art und Weise, wie ggplot seine Skalen zeichnet, etwas mehr Aufmerksamkeit zu schenken. ggplot seine Skalen zeichnet. Da jede abgebildete Variable eine Skala hat, können wir viel darüber lernen, wie ein Diagramm konstruiert wurde, wie ein Diagramm konstruiert wurde und welche Mappings es enthält, indem wir sehen, wie die Legenden aussehen aussehen. Schauen Sie sich zum Beispiel die Legenden in Abbildungen 3.15 und 3.16. In der Legende der ersten Abbildung, die in Abbildung 3.18 auf der linken Seite links, sehen wir mehrere visuelle Elemente. Der Schlüssel für jeden Kontinent zeigt einen Punkt, eine Linie und einen schattierten Hintergrund. Die Legende für die zweiten Abbildung, die rechts dargestellt ist, enthält nur einen Punkt für jeden Kontinent. ohne schattierten Hintergrund oder Linie. Wenn Sie sich noch einmal den Code der Abbildungen 3.15 und 3.16 noch einmal ansehen, werden Sie sehen, dass wir im ersten Fall die Variable continent sowohl der Farbe als auch der Füllung zugewiesen haben. Dann haben wir die Abbildung mit geom_point() gezeichnet und für jeden Kontinent eine Linie mit tinent mit geom_smooth() eine Linie angepasst. Punkte haben eine Farbe, aber der Glätter Farbe (für die Linie selbst) und Füllung (für das schattierte -->
<!-- Standardfehler-Band). Jedes dieser Elemente wird in der Legende dargestellt in der Legende dargestellt: die Punktfarbe, die Linienfarbe und die Füllung des Bandes. In der zweiten Abbildung haben wir beschlossen, die Dinge zu vereinfachen, indem wir nur -->
<!-- die Punkte durch den Kontinent gefärbt werden. Dann haben wir nur einen einzigen Glätteisen für das gesamte Diagramm. In der Legende zu dieser Abbildung sind daher sowohl die farbige Linie als auch das schattierte Kästchen fehlen. Wir sehen nur eine Legende für die Zuordnung von Farbe zu Kontinent in geom_point() . Im Diagramm selbst ist die Linie, die von geom_smooth() -->
<!-- gezeichnete Linie ist standardmäßig auf ein helles Blau eingestellt, das sich von allem auf der Skala, und das schattierte Fehlerband ist standardmäßig auf grau eingestellt. Kleine Details wie diese sind keine Zufälle. Sie sind eine direkte Konsequenz der grammatikalischen Denkweise von ggplot über die Beziehung zwischen den zwischen den Daten hinter dem Diagramm und den visuellen Elementen, die repräsentieren. -->


<!-- ## Speichern Sie Ihre Arbeit -->

<!-- Nachdem Sie nun begonnen haben, Ihre eigenen Plots zu erstellen, fragen Sie sich vielleicht, wie Sie sie speichern können und wie Sie ihre Größe und Format kontrollieren können. Wenn Sie in einem RMarkdown-Dokument arbeiten, dann werden die von Ihnen erstellten Diagramme darin eingebettet, wie wir bereits gesehen haben. Sie können die Standardgröße von Plots in Ihrem .Rmd-Dokument festlegen Rmd-Dokuments festlegen, indem Sie eine Option in Ihrem ersten Code-Baustein setzen. Diese Option weist R an, 8 x 5 Abbildungen zu erstellen:  -->

<!-- ```{r} -->
<!-- knitr::opts_chunk$set(fig.width = 8, fig.height = 5) -->
<!-- ``` -->

<!-- Da Sie Diagramme in verschiedenen Größen und Formen erstellen werden, werden Sie manchmal die Größe bestimmter Diagramme steuern wollen, ohne die Standardeinstellungen zu ändern. Zu diesem Zweck können Sie die gleichen Optionen zu jedem einzelnen Teilstück innerhalb der geschweiften Klammern am beginnen. Denken Sie daran, dass jeder Abschnitt mit drei Backticks beginnt und dann einem Paar geschweifter Klammern, die den Namen der Sprache (in unserem Fall immer r ) und eine optionale Bezeichnung: -->

<!-- ```{r example} -->
<!-- p + geom_point() -->
<!-- ``` -->

<!-- Sie können der Bezeichnung ein Komma folgen lassen und eine Reihe von Optionen angeben, falls erforderlich. Sie gelten dann nur für diesen Abschnitt. Um eine Figur zwölf Zoll breit und neun Zoll hoch zu machen, sagen wir sagen wir z. B.  -->

<!-- ```{r, fig.width = 12, fig.height = 9} -->
<!-- p + geom_point() -->
<!-- ``` -->
<!-- {r example, fig.width = 12, fig.height = 9} in der Abschnitt der geschweiften Klammern. Oft müssen Sie Ihre Figuren einzeln speichern, da sie in Folien eingefügt oder in Papieren veröffentlicht werden, die nicht mit RMarkdown erstellt wurden. Das Speichern einer Abbildung in einer Datei kann kann auf verschiedene Arten erfolgen. Bei der Arbeit mit ggplot ist der einfachste Weg, die Funktion ggsave() zu verwenden. Zum Speichern der zuletzt zuletzt angezeigte Abbildung zu speichern, geben wir den Namen an, unter dem wir sie speichern wollen unter: -->

<!-- ```{r} -->
<!-- ggsave(filename = "meine_abbildung.png") -->
<!-- ``` -->

<!-- Dadurch wird die Abbildung als PNG-Datei gespeichert, ein Format, das für die für die Anzeige auf Webseiten geeignet ist. Wenn Sie stattdessen ein PDF-Format wünschen, ändern Sie die Erweiterung der Datei: -->

<!-- ```{r} -->
<!-- ggsave(filename = "meine_abbildung.pdf") -->
<!-- ``` -->

<!-- Denken Sie daran, dass Sie der Einfachheit halber nicht schreiben müssen Dateiname = zu schreiben, solange der Name der Datei das erste Argument ist, das Sie ggsave() übergeben. Sie können auch Plot-Objekte an ggsave() übergeben. Für Beispiel: Wir können unsere aktuelle Darstellung in ein Objekt namens p_out speichern und dann ggsave() mitteilen, dass wir dieses Objekt speichern wollen. -->

<!-- ```{r} -->
<!-- p_out <- p + geom_point() + geom_smooth(method = "loess") + scale_x_log10() -->
<!-- ggsave("meine_Abbildung.pdf", plot = p_out) -->
<!-- ``` -->

<!-- Wenn Sie Ihre Arbeit speichern, ist es nützlich, einen oder mehrere Unterordner zu haben, in denen Sie nur Abbildungen speichern. Sie sollten auch darauf achten Sie sollten auch darauf achten, Ihre gespeicherten Abbildungen sinnvoll zu benennen. fig_1.pdf oder meine_Abbildung.pdf sind keine guten Namen. Die Namen der Abbildungen sollten kompakt, aber aussagekräftig sein und zwischen den Abbildungen innerhalb eines Projekt übereinstimmen. Darüber hinaus ist es, auch wenn es in der heutigen Zeit eigentlich nicht mehr der Fall sein sollte Heutzutage ist es außerdem ratsam, auf Nummer sicher zu gehen und Dateinamen zu vermeiden, die Dateinamen zu vermeiden, die Zeichen enthalten, die Ihren Code in Zukunft zum Verhängnis werden lassen. Diese gehören Apostrophe, Backticks, Leerzeichen, Schrägstriche und Anführungszeichen, und Anführungszeichen. Im Anhang finden Sie eine kurze Erläuterung, wie Sie Ihre -->
<!-- Dateien in Ihrem Projektordner organisieren. Betrachten Sie den Projektordner als die den Projektordner als Basis Ihrer Arbeit für die Arbeit, die Sie gerade verfassen, und legen Sie Ihre Daten und Abbildungen in Unterordnern innerhalb des Projektordners ab. Unter erstellen Sie zunächst mit Ihrem Dateimanager einen Ordner mit dem Namen "figures" innerhalb Ihres Projektordners. Zum Speichern von Zahlen können Sie Kirill Müllers praktische Bibliothek verwenden, die Ihnen die Arbeit mit Dateien und und Unterordnern zu arbeiten, ohne die vollständigen Dateipfade eintippen zu müssen. Laden Sie die Bibliothek in den Setup-Knoten Ihres RMarkdown-Dokuments. Wenn Sie wird Ihnen angezeigt, wo sich "here" für das aktuelle Projekt befindet. Sie werden sehen eine Meldung, die in etwa so lautet, mit Ihrem Dateipfad und Benutzernamen anstelle von meinem: -->

<!-- ```{r} -->
<!-- # here() beginnt unter /Users/kjhealy/projects/socviz -->
<!-- ``` -->

<!-- Sie können dann die Funktion here() verwenden, um das Laden und Speichern Ihrer Arbeit einfacher und sicherer zu machen. Angenommen, ein Ordner mit dem Namen "figures" in Ihrem Projektordner existiert, können Sie dies tun:  -->

<!-- ```{r} -->
<!-- #ggsave(here("figures", "lifexp_vs_gdp_gradient.pdf"), plot = p_out) -->
<!-- ``` -->

<!-- Dies speichert p_out als eine Datei namens lifeexp_vs_gdp_gradient.pdf im dem Verzeichnis figures, d. h. in Ihrem aktuellen Projektordner. Sie können Ihre Abbildung in einer Vielzahl von Formaten speichern, je nach Ihren Bedürfnissen (und auch, in geringerem Maße, von Ihrem speziellen Computer Computersystem). Die wichtigste Unterscheidung, die Sie im Auge behalten sollten ist die Unterscheidung zwischen Vektorformaten und Rasterformaten. Eine Datei mit einem Vektor Vektorformat, wie PDF oder SVG, wird als eine Reihe von Anweisungen über Linien, Formen, Farben und deren Beziehungen gespeichert. Die Betrachtungssoftware (wie Adobe Acrobat oder Apples Preview-Anwendung für PDFs) interpretiert dann diese Anweisungen und zeigt die Abbildung an. Die Darstellung - Diese Art der Darstellung ermöglicht es, die Größe der Abbildung leicht zu verzerrt wird. Die zugrunde liegende Sprache des PDF-Formats ist Postscript, das auch die Sprache des modernen Schriftsatzes und und des Drucks ist. Das macht ein vektorbasiertes Format wie PDF zur besten beste Wahl für die Einreichung bei Zeitschriften. Ein rasterbasiertes Format hingegen speichert Bilder im Wesentlichen als Rasterformate hingegen speichern Bilder im Wesentlichen als ein Raster von Pixeln einer vordefinierten Größe mit Informationen über Informationen über die Position, Farbe, Helligkeit usw. jedes Pixels im -->
<!-- Raster. Dies ermöglicht eine effizientere Speicherung, vor allem wenn es in Verbindung mit Komprimierungsmethoden, die die Redundanz in Bildern ausnutzen Redundanz in Bildern nutzen, um Platz zu sparen. Formate wie JPG sind komprimierte Rasterformate. Eine PNG-Datei ist ein Rasterbildformat, das verlustfreie Komprimierung unterstützt. Bei Diagrammen, die eine große Menge Daten enthalten, sind PNG-Dateien in der Regel viel kleiner als das entsprechende entsprechende PDF-Datei. Allerdings können Rasterformate nicht einfach in der Größe verändert werden. Insbesondere können sie nicht vergrößert werden, ohne dass sie -->
<!-- pixelig oder körnig zu werden. Formate wie JPG und PNG sind die Standard die Standardformate für die Darstellung von Bildern im Internet. Das neuere SVG Format ist ein vektorbasiertes Format, das dennoch von vielen -->
<!-- vielen Webbrowsern unterstützt. Im Allgemeinen sollten Sie Ihre Arbeit in mehreren verschiedenen Formaten speichern. maten speichern. Wenn Sie in verschiedenen Formaten und Größen speichern, müssen Sie Größe müssen Sie eventuell mit der Skalierung der Grafik und der Größe der der Schriftarten experimentieren, um ein gutes Ergebnis zu erzielen. Das Argument scale für -->
<!-- ggsave() kann Ihnen hier helfen (Sie können verschiedene Werte ausprobieren, wie scale=1.3 , scale=5 , und so weiter). Sie können auch ggsave() verwenden, um die Höhe und Breite Ihres Diagramms explizit in den von Ihnen gewählten Einheiten die Sie wählen. -->

<!-- ```{r} -->
<!-- # ggsave(here("figures", "lifexp_vs_gdp_gradient2.pdf"), plot = p_out, -->
<!-- #        height = 8, width = 10, units = "in") -->
<!-- ``` -->





<!-- ## Scales -->


<!-- Wenn unser Ziel an dieser Stelle nur darin bestünde, ein Diagramm der Lebenserwartung im Vergleich zum Lebenserwartung im Vergleich zum BIP unter Verwendung sinnvoller Skalen und einer Glättung zu zeigen, würden wir darüber nachdenken, das Diagramm mit schöneren Achsenbeschriftungen und einem Titel. Vielleicht sollten wir auch die wissenschaftliche Notation auf der x-Achse durch den tatsächlichen Dollarwert ersetzen. Beides lässt sich recht einfach bewerkstelligen. Kümmern wir uns zunächst um die Skala kümmern. Die Beschriftung der Tick-Marken kann über die die scale_ Funktionen. Es ist zwar möglich, eine eigene Funktion für die Achsenbeschriftung zu entwickeln (oder die Beschriftungen manuell einzugeben, wie wir später sehen werden). später sehen werden), gibt es auch ein praktisches Skalenpaket, das einige nützliche fertige Formatierungsfunktionen enthält. Wir können entweder das gesamte Paket mit library(scales) laden oder, was noch bequemer ist, einfach den gewünschten Formatierer aus dieser Bibliothek. Hier ist es die dollar()-Funktion. Um eine Funktion direkt aus einem Paket zu holen, das wir nicht geladen haben, verwenden wir die Syntax thepackage::thefunction . Also können wir dies tun: -->


<!-- ```{r} -->
<!-- p + geom_point() + -->
<!--   scale_x_continuous(limits = c(0, 13),  -->
<!--                      breaks = seq(0, 13, 2), -->
<!--                      labels = scales::dollar) +  -->
<!--   scale_y_continuous(limits = c(50, 90),  -->
<!--                      breaks = seq(50, 90, 5)) + -->
<!--   labs(x = "Gesundheitsausgaben",  -->
<!--        y = "Lebenserwartung",  -->
<!--        title = "Überschrift",  -->
<!--        subtitle = "Unterüberschrift",  -->
<!--        caption = "Quelle: QOG") -->

<!-- ``` -->



<!-- ```{r} -->
<!-- p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) -->
<!-- p + geom_point() + -->
<!-- geom_smooth(method = "gam") + -->
<!-- scale_x_log10(labels = scales::dollar) -->
<!-- ``` -->




<!-- ## Including Plots -->

<!-- You can also embed plots, for example: -->

<!-- ```{r pressure, echo=FALSE} -->
<!-- plot(pressure) -->
<!-- ``` -->

<!-- Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. -->



```{r, echo=FALSE}
# g <- ggplot(qog_ts, aes(x = year, y = gle_gdp))
# g <- ggplot(qog, aes(x = cname, y = ffp_sl, color = cname))
# 
# g + geom_point()
# 
# g <- ggplot(qog_ts, aes(x = year, y = wdi_hwf, color = cname))
# g <- ggplot(qog, aes(y = wdi_incsh10h, x = who_let))
# g + geom_point()

# 
# g <- ggplot(qog, aes(x = wdi_chexppgdp, y = wdi_lifexp))
# g + geom_point()
# 
# g <- ggplot(qog, aes(x = wdi_chexppgdp, y = wdi_lifexp))
# g + geom_point()
# 
# 
# 
# g <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = wdi_pop, color = continent))
# g + geom_point()
# 
# g <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# 
# summary(qog$wdi_pop)
# 
# g <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, size = wdi_pop, shape = continent))
# g + geom_point()
# 
# 
# g <- ggplot(qog, aes(x = wdi_dgovhexp, y = wdi_lifexp, color = continent))
# g + geom_text(label = qog$continent)
# 
# 
# p <- ggplot(qog, aes(x = wdi_lifexp))
# p + geom_area(stat = "bin", binwidth = 1)
# p + geom_histogram()
# p + geom_histogram(binwidth = 0.5)
# p + geom_histogram(binwidth = 1.5)
# p + geom_dotplot()
# p + geom_freqpoly()
# p + geom_density()
# p + geom_histogram(binwidth = 1.5) +
#   geom_freqpoly(binwidth = 1.5)
# 
# 
# p + geom_histogram(binwidth = 1, aes(y=..density..)) +
#   geom_density()
# 
# 
# p + geom_histogram(binwidth = 1, aes(y=..density..),
#                    fill = "lightgrey", color = "blue") +
#   geom_density(size = 2, color = "skyblue")
# 
# qog_sum <-
# qog %>%
#   select(wdi_dgovhexp, wdi_lifexp, wdi_lifexp, wdi_pop, continent) %>%
#   group_by(continent) %>%
#   summarise_if(is.numeric, mean, na.rm = TRUE)
# 
# p <- ggplot(qog_sum, aes(y=wdi_lifexp, x = continent))
# p + geom_bar(stat = "identity")
# 
# p <- ggplot(qog, aes(x=wdi_lifexp, fill = continent))
# p + geom_bar(position = "dodge")
# p + geom_bar(position = "stack")
# p + geom_bar(position = "fill")
# 
# 
# p <- ggplot(qog, aes(y=wdi_lifexp, x = continent))
# p + geom_boxplot()
# p + geom_violin()
# p + geom_violin() + geom_boxplot(alpha=0.5)
# p + geom_violin() + geom_point()
# p + geom_violin() + geom_jitter(width = 0.1)
# p + geom_boxplot() + geom_jitter(width = 0.1)
# 
# 
# p <- ggplot(qog_ts, aes(x=year,  y=wdi_lifexp))
# p + geom_line() +
#   facet_wrap(~cname)
# 
# p + geom_path() +
#   facet_wrap(~continent)
# 
# qog_ts_sum <-
# qog_ts %>%
#   select(year, wdi_dgovhexp, wdi_lifexp, wdi_pop, continent) %>%
#   group_by(year, continent) %>%
#   summarise_if(is.numeric, mean, na.rm = TRUE)
# 
# 
# p <- ggplot(qog_ts_sum, aes(x=year,  y=wdi_lifexp))
# p + geom_line() +
#   facet_wrap(~continent)
# 
# 
# qog_ts %>%
#   filter(continent == "Africa") %>%
#   ggplot(., aes(x=year,  y=wdi_lifexp)) +
#   #geom_point(size = 0.5) +
#   geom_line() +
#   facet_wrap(~ccodealp)
# 
# # State Legitimacy (ffp_sl)
# # Corruption Perceptions Index (ti_cpi)
# # Political corruption index (vdem_corr)
# # Overall Global Gender Gap Index (gggi_ggi)
# # Urban population (% of total population) (wdi_popurb)
# # Rural population (% of total population) (wdi_poprul)
# # Post-Materialist index 12-item (wvs_pmi12)
# # Post-Materialist index 4-item (wvs_pmi4)
# # Autonomy Index (wvs_auton)
# # Emancipative Values: Autonomy Component (wel_evau)
# # Emancipative Values: Choice Component (wel_evch)
# # Emancipative Values Index (wel_evi)
# # Emancipative Values: Voice Component (wel_evvo)
# # Political Terror Scale - Amnesty International (gd_ptsa)
# # Political Terror Scale - Human Rights Watch (gd_ptsh)
# # Percentage with No Schooling, Female and Male (bl_lumf)
# # Literacy rate, adult total (% of people ages 15 and above) (wdi_litrad)
# # Adjusted net enrollment rate, primary (% of primary school children) (wdi_nerpr)
# # Access to electricity (% of population) (wdi_acel)
# # Access to electricity, rural (% of rural population) (wdi_acelr)
# # Access to electricity, urban (% of urban population) (wdi_acelu)
# # Alternative and nuclear energy (% of total energy use) (wdi_ane)
# # Internet users. % pop. (wef_iu)
# # Current health expenditure (% of GDP) (wdi_chexppgdp)
# # Human Development Index (undp_hdi)
# # People with basic handwashing facilities (% of populartion) (wdi_hwf)
# # People with basic handwashing facilities, rural (% of rural population) (wdi_hwfr)
# # People with basic handwashing facilities, urban (% of urban population) (wdi_hwfu)
# # Alcohol consumption per capita (who_alcohol10)
# # Healthy Life Expectancy, Female (who_halef)
# # Healthy Life Expectancy, Male (who_halem)
# # Healthy Life Expectancy, Total (who_halet)
# # Life Expectancy, Female (who_lef)
# # Life Expectancy, Male (who_lem)
# # Life Expectancy, Total (who_let)
# # State of health (subjective) (wvs_subh)
# # Colonial Origin (ht_colonial)
# # Real GDP per Capita (year 1600) (mad_gdppc1600)
# # Real GDP per Capita (year 1700) (mad_gdppc1700)
# # Real GDP per Capita (year 1900) (mad_gdppc1900)
# # Rule of law sub-index (aii_rol)
# # Rule of Law (bti_rol)
# # Eective Number of Electoral Parties (gol_enep)
# # Index of Democratization (van_index)
# # Democratic Breakdown (bnr_dem)
# # Approval of Democracy (bti_aod)
# # Democracy Status (bti_ds)
# # Quality of Democracy (sgi_qd) 493
# # Index of Democratization (van_index) 530
# # Liberal democracy index (vdem_libdem) 537
# # Eective Democracy Index (wel_edi) 641
# # Political system: Having a democratic political system (wvs_psdem) 670
# # Real GDP (2005) (gle_gdp) 304
# # Real GDP per Capita (2005) (gle_rgdpc) 305
# # Gini Coecient (lis_gini) 393
# # Mean Equivalized Income (lis_meaneqi) 394
# # Real GDP per Capita (mad_gdppc) 399
# # Real GDP at constant 2017 national prices (in mil. 2017US dollar) (pwt_rgdp) 476
# # GDP per capita (constant 2010 US dollar) (wdi_gdpcapcon2010)
# # GDP per capita, PPP (constant 2017 international dollar) (wdi_gdpcappppcon2017)
# # GDP, PPP (constant 2017 international dollar) (wdi_gdppppcon2017)
# # Income share held by highest 10% (wdi_incsh10h) 587
# # Scientic publications. H Index (wef_sp) 636
# # Expenditure on health, as % of total gen. gov. exp. (gfs_heal) 300
# 
# 
# g <- ggplot(qog, aes(x = van_index, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# g <- ggplot(qog, aes(x = wbgi_pve	, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# 
# g <- ggplot(qog, aes(x = gd_ptsh, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# g <- ggplot(qog, aes(x = gd_ptsa, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# 
# 
# g <- ggplot(qog, aes(x = ht_colonial, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# 
# g <- ggplot(qog, aes(x = wdi_hwf, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# 
# g <- ggplot(qog, aes(x = wdi_gdpcapcon2010, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))
# 
# 
# g <- ggplot(qog, aes(x = wdi_gdppppcon2017, y = wdi_lifexp, size = wdi_pop, fill = continent))
# g + geom_point(shape = 21) +
#   scale_size(name   = "qsec",
#              breaks = c(1000000, 10000000, 100000000, 1000000000),
#              labels = expression("< 1 Mio.", "bis 10 Mio.", "< 100 Mio.", ""))

```


